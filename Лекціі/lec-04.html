<!DOCTYPE html>
<html>
<head>
	<title>Інструментальні засоби візуального програмування. Лекція №4 </title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
	<div class="paper">
		<div id="colontitle">Інструментальні засоби візуального програмування. Лекція №4 </div>
		<h1>Використання суперглобальних масивів. Передача даних методами POST та GET</h1>
		


		<h3>Протокол HTTP і способи передачі даних на сервер</h3>
		
		<p>HTTP (HyperText Transfer Protocol, протокол передачі гіпертексту) - це протокол прикладного рівня, розроблений для обміну гіпертекстової інформацією в Internet.
		</p>
		
		<p><strong>HTTP</strong> надає набір методів для вказівки цілей запиту, що відправляється серверу. Ці методи основані на узгодженості посилань, де для вказівки ресурсу, до якого має бути застосований даний метод, використовується універсальний ідентифікатор ресурсів (Universal Resource Identifier) у вигляді місцезнаходження ресурсу (Universal Resource Locator, URL) або у вигляді його універсального імені (Universal Resource Name , URN).
		</p>
		
		<p>Повідомлення по мережі при використанні протоколу HTTP передаються у форматі, схожому з форматом поштового повідомлення Internet (RFC-822) або з форматом повідомлень MIME (Multipurpose Internet Mail Exchange).
		</p>
		
		<p>HTTP використовується для комунікацій між різними користувацькими програмами та програмами-шлюзами, що надають доступ до існуючих Internet-протоколів, таких як SMTP (протокол електронної пошти), NNTP (протокол передачі новин), FTP (протокол передачі файлів), Gopher і WAIS. HTTP розроблений для того, щоб дозволяти таким шлюзам через проміжні програми-сервери (proxy) передавати дані без втрат.
		</p>
		
		<p>Протокол реалізує принцип запит / відповідь. Запитуюча програма-клієнт ініціює взаємодію з відповідною програмою-сервером, і надсилає запит, який містить:
		</p>
		<ul>
			<li>метод доступу;</li>
			<li>адресу URI;</li>
			<li>версію протоколу;</li>
			<li>повідомлення (схоже за формою на MIME) з інформацією про тип переданих даних, інформацією про клієнта, що послав запит, і, можливо, із змістовною частиною (тілом) повідомлення.</li>
		</ul>
		
		<p><strong>Відповідь сервера містить:</strong>
		</p>
		<ul>
			<li>рядок стану, в яку входить версія протоколу і код повернення (успіх або помилка);</li>
			<li>повідомлення (у формі, схожій на MIME), до якого входить інформація сервера, метаінформація (тобто інформація про зміст повідомлення) і тіло повідомлення.</li>
		</ul>

		<p>У протоколі не вказується, хто повинен відкривати і закривати з'єднання між клієнтом і сервером. На практиці з'єднання, як правило, відкриває клієнт, а сервер після відправки відповіді ініціює його розриває.
		</p>
		<h3>Форма запиту клієнта</h3>
		
		<p>Клієнт відсилає серверу запит в одній з двох форм: у повній або скороченій. Запит у першій формі називається відповідно повним запитом, а в другій формі - простим запитом.
		</p>
		
		<p>Простий запит містить метод доступу та адресу ресурсу. Формально це можна записати так:
		</p>
		<p>&lt;Простий-Запит&gt;: = &lt;Метод&gt; &lt;символ пробіл&gt;  &lt;Запитуваний-URI&gt; &lt;символ нового рядка&gt;
		</p>
		
		<p>В якості методу можуть бути вказані GET, POST, HEAD, PUT, DELETE та інші. Про найбільш поширені з них ми поговоримо трохи пізніше. В якості запитуваної URI найчастіше використовується URL-адреса ресурсу.
		</p>
		<p><strong>Приклад простого запиту:</strong>  GET <a href="http://phpbook.info/">http://phpbook.info/</a>
		</p>
		
		<p>Тут <strong>GET</strong> - це метод доступу, тобто метод, який повинен бути застосований до запитуваного ресурсу, а <a href="http://phpbook.info/">http://phpbook.info/</a> - це URL-адреса запитуваного ресурсу.
		</p>
		
		<p>Повний запит містить рядок стану, кілька заголовків (заголовок запиту, загальний заголовок або заголовок запису) і, можливо, тіло запиту. Формально загальний вигляд повного запиту можна записати так:
		</p>
		<p>&lt;Повний запит&gt;: = &lt;Рядок Стану&gt;  (&lt;Загальний заголовок&gt; | &lt;Тема запиту&gt; |  &lt;Заголовок змісту&gt;)  &lt;Символ нового рядка&gt;  [&lt;Зміст запиту&gt;]
		</p>
		
		<p>Квадратні дужки тут позначають необов'язкові елементи заголовка, через вертикальну риску перераховані альтернативні варіанти. Елемент &lt;Рядок стану&gt; містить метод запиту та URI ресурсу (як і простий запит) і, крім того, використовувану версію протоколу HTTP. Наприклад, для виклику зовнішньої програми можна задіяти наступний рядок стану:
		</p>
		
		<p>POST <a href="http://phpbook.info/cgi-bin/test">http://phpbook.info/cgi-bin/test</a> HTTP/1.0
		</p>
		
		<p>У даному випадку використовується метод POST і протокол HTTP версії 1.0.
		</p>
		
		<p>В обох формах запиту важливе місце займає URI запитуваного ресурсу. Найчастіше URI використовується у вигляді URL-адреси ресурсу. При зверненні до сервера можна застосовувати як повну форму URL, так і спрощену.
		</p>
		
		<p>Повна форма містить тип протоколу доступу, адресу сервера ресурсу та адресу ресурсу на сервері (рис 1).
		</p>
		
		<p>У скороченій формі опускають протокол і адресу сервера, вказуючи лише місце розташування ресурсу від кореня сервера. Повну форму використовують, якщо можливе пересилання запиту іншого сервера. Якщо ж робота відбувається тільки з одним сервером, то частіше застосовують скорочену форму.
		</p>
		<p><img src="img/04001.png">  Рис. 1. Повна форма URL
		</p>
		<h3>Методи</h3>
		
		<p>Метод повідомляє про мету запиту клієнта. Протокол HTTP підтримує досить багато методів, але реально використовуються тільки три: POST, GET і HEAD. Метод GET дозволяє отримати будь-які дані, ідентифіковані за допомогою URI в запиті ресурсу. Якщо URI вказує на програму, то повертається результат роботи програми, а не її текст (якщо, звичайно, текст не є результат її роботи). Додаткова інформація, необхідна для обробки запиту, вбудовується в сам запит (у рядок статусу). При використанні методу GET у поле тіла ресурсу повертається власне затребувана інформація (текст HTML-документа, наприклад).
		</p>
		
		<p>Існує різновид методу GET - <strong>умовний GET.</strong> Цей метод повідомляє серверу про те, що на запит потрібно відповісти, тільки якщо виконуються умови, що міститься в полі if-Modified-Since заголовка запиту. Якщо говорити більш точно, то тіло ресурсу передається у відповідь на запит, якщо цей ресурс змінювався після дати, зазначеної в if-Modified-Since.
		</p>
		
		<p>Метод <strong>HEAD</strong> аналогічний методу GET, тільки не повертає тіло ресурсу і не має умовного аналога. Метод HEAD використовують для отримання інформації про ресурс. Це може стати в нагоді, наприклад, при вирішенні завдання тестування гіпертекстових посилань.
		</p>
		
		<p>Метод <strong>POST</strong> розроблений для передачі на сервер такої інформації, як анотації ресурсів, новини і поштові повідомлення, дані для додавання в базу даних, тобто для передачі інформації великого обсягу і досить важливої. На відміну від методів GET і HEAD, в POST передається тіло ресурсу, яке і є інформацією, одержану з полів форм або інших джерел введення.
		</p>
		
		<p>До цих пір ми тільки теоретизували, знайомилися з основними поняттями. Тепер варто навчитися використовувати все це на практиці. Далі в лекції ми розглянемо, як посилати запити серверу і як обробляти його відповіді.
		</p>
		<h3>Використання HTML-форм для передачі даних на сервер</h3>
		
		<p>Як передавати дані серверу? Для цього в мові HTML є спеціальна конструкція - <strong>форми.</strong> Форми призначені для того, щоб отримувати від користувача інформацію. Наприклад, вам потрібно знати логін і пароль користувача для того, щоб визначити, на які сторінки сайту його можна допускати. Або вам необхідні особисті дані користувача, щоб була можливість з ним зв'язатися. Форми якраз і застосовуються для введення такої інформації. У них можна вводити текст або вибирати підходящі варіанти зі списку. Дані, записані у форму, відправляються для обробки спеціальною програмою (наприклад, скриптом на PHP) на сервері. Залежно від введених користувачем даних ця програма може формувати різні web-сторінки, відправляти запити до бази даних, запускати різні додатки і т.п.
		</p>
		
		<p>Розберемося з синтаксисом HTML-форм. Можливо, багато хто з ним знайомий, але ми все ж повторимо основні моменти, оскільки це важливо.
		</p>
		
		<p>Отже, для створення форми мовою HTML використовується тег FORM. Всередині нього знаходиться одна або декілька команд INPUT. За допомогою атрибутів action і method тега FORM задаються ім'я програми, яка буде обробляти дані форми, і метод запиту, відповідно. Команда INPUT визначає тип і різні характеристики запитуваної інформації. Надсилання даних форми відбувається після натискання кнопки input типу submit. Створимо форму для реєстрації учасників заочної школи програмування.
		</p>
		<p>&lt;h2&gt; Форма для реєстрації учасників &lt;/ h2&gt;  &lt;form action="1.php" method=POST&gt;   При відправленні запиту буде використаний метод POST -&gt;  Ім'я &lt;br&gt; &lt;input type = text name = "first_name"  value = "Ваше ім'я"&gt; &lt;br&gt;  Прізвище &lt;br&gt; &lt;input type=text name="last_name"&gt; &lt;br&gt;  E-mail &lt;br&gt; &lt;input type=text name="email"&gt; &lt;br&gt;  &lt;p&gt;  Виберіть курс, який ви б хотіли відвідувати: &lt;br&gt;  &lt;input type=radio name="kurs" value="PHP"&gt; PHP &lt;br&gt;  &lt;input type=radio name="kurs" value="Lisp"&gt; Lisp &lt;br&gt;  &lt;input type=radio name="kurs" value="Perl"&gt; Perl &lt;br&gt;  &lt;input type=radio name="kurs" value="Unix"&gt; Unix &lt;br&gt;  &lt;P&gt; Що ви хочете, щоб ми знали про вас? &lt;BR&gt;  &lt;textarea name="comment" cols=32 rows=5&gt;  &lt;P&gt; &lt;Input name = "confirm" type = checkbox  checked&gt; Підтвердити отримання &lt;br&gt;  &lt;input type=submit value="Відправити"&gt;  &lt;input type=reset value="Відмініти"&gt;   
		</p>
		
		
		<h3>Для методу GET</h3>
		
		<p>Для методу GET При відправці даних форми за допомогою методу GET вміст форми додається до URL після знака запитання у вигляді пар імен = значення, об'єднаних за допомогою амперсанда &amp;:
		</p>
		
		<p>action?name1=value1=name2=value2&amp;name3=value3
		</p>
		
		<p>Тут action - це URL-адреса програми, яка повинна обробляти форму (це або програма, задана в атрибуті action тега form, або сама поточна програма, якщо цей атрибут опущений). Імена name1, name2, name3 відповідають іменам елементів форми, а value1, value2, value3 - значення цих елементів. Всі спеціальні символи, включаючи = і &amp;, в іменах або значеннях цих параметрів будуть закодовані. Тому не варто використовувати в назвах або значеннях елементів форми ці символи і символи кирилиці в ідентифікаторах.
		</p>
		
		<p>Якщо в полі для введення ввести який-небудь службовий символ, то він буде переданий в його шістнадцятковому коді, наприклад, символ $ заміниться на% 24. Так само передаються і кирилиця.
		</p>
		
		<p>Для полів введення тексту і пароля (це елементи input з атрибутом type = text і type = password), значенням буде те, що введе користувач. Якщо користувач нічого не вводить в таке поле, то в рядку запиту буде присутній елемент name =, де name відповідає імені цього елемента форми.
		</p>
		
		<p>Для кнопок типу <strong>checkbox</strong> і <strong>radio button </strong>значення <strong>value </strong>визначається атрибутом VALUE в тому випадку, коли кнопка відзначена. Не зазначені кнопки при складанні рядка запиту ігноруються повністю. Кілька кнопок типу checkbox можуть мати один атрибут NAME (і різні VALUE), якщо це необхідно. Кнопки типу radio button призначені для одного з усіх запропонованих варіантів і тому повинні мати однаковий атрибут NAME і різні атрибути VALUE.
		</p>
		
		<p>У принципі створювати HTML-форму для передачі даних методом GET не обов'язково. Можна просто додати рядок URL потрібні змінні та їх значення.
		</p>
		
		<p><a href="http://phpbook.info/test.php?id=10&amp;user=pit">http://phpbook.info/test.php?id=10&amp;user=pit</a>
		</p>
		
		<p>У зв'язку з цим у передачі даних методом GET є один істотний недолік - будь-хто може підробити значення параметрів. Тому не радимо використовувати цей метод для доступу до захищених паролем сторінок, для передачі інформації, що впливає на безпеку роботи програми або сервера. Крім того, не варто застосовувати метод GET для передачі інформації, яку не дозволено змінювати користувачеві.
		</p>
		
		<p>Незважаючи на всі ці недоліки, використовувати метод GET досить зручно при налагодженні скриптів (можна бачити значення й імена переданих змінних) і для передачі параметрів, які не впливають на безпеку.
		</p>
		<h3>Для методу POST</h3>
		
		<p>Вміст форми кодується точно так само, як для методу <strong>GET</strong>, але замість додавання рядка до <strong>URL</strong> вміст запиту надсилається блоком даних як частина операції POST. Якщо присутній атрибут <strong>ACTION</strong>, то значення <strong>URL</strong>, яке там знаходиться, визначає, куди посилати цей блок даних. Цей метод, як уже зазначалося, рекомендується для передачі великих за обсягом блоків даних.
		</p>
		
		<p>Інформація, введена користувачем і відправлена серверу за допомогою методу POST, подається на стандартне введення програми, зазначеної в атрибуті action, чи поточного скрипту, якщо цей атрибут опущений. Довжина посилається файлу передається у змінній оточення CONTENT_LENGTH, а тип даних - у змінній CONTENT_TYPE.
		</p>
		
		<p>Передати дані методом POST можна тільки за допомогою HTML-форми, оскільки дані передаються в тілі запиту, а не в заголовку, як у GET. Відповідно і змінити значення параметрів можна, тільки змінивши значення, введене в форму. При використанні POST користувач не бачить чи передаються серверу дані.
		</p>
		
		<p><em>Основна перевага POST запитів </em>- це їхня велика безпека і функціональність у порівнянні з GET-запитами. Тому метод POST частіше використовують для передачі важливої інформації, а також інформації великого обсягу. Тим не менш не варто цілком покладатися на безпеку цього механізму, оскільки дані POST запиту також можна підробити, наприклад створивши html-файл на своїй машині і заповнивши його потрібними даними. Крім того, не всі клієнти можуть застосовувати метод POST, що обмежує варіанти його використання.
		</p>
		
		<p>При відправці даних на сервер будь-яким методом передаються не тільки самі дані, введені користувачем, але і ряд змінних, які називаються змінними середовища, що характеризують клієнта, історію його роботи, шляхи до файлів і т.п. Ось деякі із змінних оточення:
		</p>
		<ul>
			<li>REMOTE_ADDR - IP-адреса хоста (комп'ютера), що відправляє запит;</li>
			<li>REMOTE_HOST - ім'я хоста, з якого надіслано запит;</li>
			<li>HTTP_REFERER - адреса сторінки, що посилається на поточний скрипт;</li>
			<li>REQUEST_METHOD - метод, який був використаний при відправці запиту;</li>
			<li>QUERY_STRING - інформація, яка перебуває в URL після знака питання;</li>
			<li>SCRIPT_NAME - віртуальний шлях до програми, яка повинна виконуватися;</li>
			<li>HTTP_USER_AGENT - інформація про браузер, який використовує клієнт</li>
		</ul><h3>Обробка запитів за допомогою PHP</h3>
		
		<p>До цих пір ми згадували тільки, що запити клієнта обробляються на сервері за допомогою спеціальної програми. Насправді цю програму ми можемо написати самі, в тому числі і на мові PHP, і вона буде робити з отриманими даними все, що ми захочемо. Для того, щоб написати цю програму, необхідно познайомитися з деякими правилами і інструментами, запропонованими для цих цілей PHP.
		</p>
		
		<p>Усередині PHP-скрипта є декілька способів отримання доступу до даних, переданим клієнтом по протоколу HTTP. До версії PHP 4.1.0 доступ до таких даних здійснювався за іменами переданих змінних (нагадаємо, що дані передаються у вигляді пар «ім'я змінної, символ« = », значення змінної»). Таким чином, якщо, наприклад, було передано first_name = Nina, то всередині скрипта з'являлася змінна $first_name зі значенням Nina. Якщо потрібно розрізняти, яким методом були передані дані, то використовувалися асоціативні масиви $HTTP_POST_VARS і $HTTP_GET_VARS, ключами яких були імена переданих змінних, а значеннями - відповідно значення цих змінних. Таким чином, якщо пара first_name = Nina передана методом GET, то $ HTTP_GET_VARS ["first_name"] = "Nina".
		</p>
		
		<p>Використовувати в програмі імена переданих змінних безпосередньо небезпечно. Тому було вирішено починаючи з PHP 4.1.0 задіяти для звернення до змінних, переданих за допомогою HTTP-запитів, спеціальний масив - $ _REQUEST. Цей масив містить дані, передані методами POST і GET, а також за допомогою HTTP cookies. Це Суперглобальний асоціативний масив, тобто його значення можна отримати в будь-якому місці програми, використовуючи як ключ ім'я відповідної змінної (елементу форми).
		</p>
		
		<p>Приклад 2. Припустимо, ми створили форму для реєстрації учасників заочної школи програмування, як у наведеному вище прикладі. Тоді у файлі 1.php, що обробляє цю форму, можна написати наступне:
		</p>
		<p>&lt;? Php  $str = "Здрастуйте,  ". $_REQUEST [" First_name "]."  ". $_REQUEST [" Last_name "]."! &lt;br&gt; ";  $str .= "Ви обрали для вивчення курс по  ". $_REQUEST [" Kurs "];  echo $str;  ?&gt;
		</p>
		
		<p>Тоді, якщо в формі ми ввели ім'я «Вася», прізвище «Петров» і вибрали серед усіх курсів курс по PHP, на екрані браузера отримаємо таке повідомлення:
		</p>
		<p>Здравствуйте, Вася Петров!  Ви обрали для вивчення курс по PHP
		</p>
		
		<p>Після введення масиву $_REQUEST масиви $HTTP_POST_VARS і $HTTP_GET_VARS для однорідності були перейменовані в $_POST і $_GET відповідно, але самі вони з вжитку не зникли з міркувань сумісності з попередніми версіями PHP. На відміну від своїх попередників, масиви $_POST і $_GET стали суперглобальними, тобто доступними безпосередньо і всередині функцій і методів.
		</p>
		
		<p>Наведемо приклад використання цих масивів. Припустимо, нам потрібно обробити форму, що містить елементи введення з іменами first_name, last_name, kurs (наприклад, форму form.html, наведену вище). Дані були передані методом POST, і дані, передані іншими методами, ми обробляти не хочемо. Це можна зробити наступним чином:
		</p>
		<p>&lt;? Php  $Str = "Здрастуйте,  ". $_POST [" First_name "]."  ". $_POST [" Last_name "]."! &lt;br&gt; ";  $Str .= "Ви обрали для вивчення курс по".  $_POST ["Kurs"];  echo $Str;  ?&gt;
		</p>
		
		<p>Тоді на екрані браузера, якщо ми ввели ім'я «Вася», прізвище «Петров» і вибрали серед усіх курсів курс по PHP, побачимо повідомлення, як у попередньому прикладі:
		</p>
		<p>Здравствуйте, Вася Петров!  Ви обрали для вивчення курс по PHP
		</p>
		
		<p>Для того, щоб зберегти можливість обробки скриптів більш ранніх версій, ніж PHP 4.1.0, була введена директива register_globals, що дозволяє чи забороняє доступ до змінних безпосередньо за їхніми іменами. Якщо у файлі налаштувань PHP параметр register_globals = On, то до змінних, переданим сервера методами GET і POST, можна звертатися просто за їхніми іменами (тобто можна писати $first_name). Якщо ж register_globals = Off, то потрібно писати $_REQUEST ["first_name"] або $_POST ["first_name"], $_GET ["first_name"], $HTTP_POST_VARS ["first_name"], $HTTP_GET_VARS ["first_name"]. З точки зору безпеки цю директиву краще відключати (тобто register_globals = Off). При включеній директиві register_globals перераховані вище масиви також будуть містити дані, передані клієнтом.
		</p>
		
		<p>Іноді виникає необхідність дізнатися значення якої-небудь змінної оточення, наприклад метод, що використовувався при передачі запиту або IP-адреса комп'ютера, що відправив запит. Отримати таку інформацію можна за допомогою функції getenv(). Вона повертає значення змінної оточення, ім'я якої передано їй як параметр.
		</p>
		<p>&lt;?  getenv ('REQUEST_METHOD');  // Поверне використаний метод  echo getenv ('REMOTE_ADDR');  // Виведе IP-адресу користувача,  // Послав запит  ?&gt;
		</p>
		
		<p>Все, що записано в URL після знака запитання, можна отримати за допомогою команди
		</p>
		
		<p><strong>getenv ('QUERY_STRING')</strong>;
		</p>
		
		<p>Завдяки цьому можна методом GET передавати дані в якому-небудь іншому вигляді. Наприклад, вказувати тільки значення декількох параметрів через знак плюс, а в скрипті розбивати рядок запиту на частини або можна передавати значення лише одного параметра. У цьому випадку в масиві $_GET з'явиться порожній елемент з ключем, рівним цьому значенню (всього рядка запиту), причому символ «+», що зустрівся в рядку запиту, буде замінений на підкреслення «_».
		</p>
		
		<p>Методом POST дані передаються тільки за допомогою форм, і користувач (клієнт) не бачить, які саме дані відправляються серверу. Щоб їх побачити, хакер повинен підмінити нашу форму на власну. Тоді сервер відправить результати обробки неправильної форми не туди, куди потрібно. Щоб цього уникнути, можна перевіряти адресу сторінки, з якої були надіслані дані. Це можна зробити знову ж за допомогою функції getenv ():
		</p>
		
		<p><strong>getenv ('HTTP_REFERER')</strong>;
		</p>
		<h3>Приклад обробки запиту за допомогою PHP</h3>
		
		<p>Нагадаємо, в чому полягало завдання, і уточнимо його формулювання. Потрібно написати форму для реєстрації учасників заочної школи програмування і після реєстрації відправити учаснику повідомлення. Ми назвали це повідомлення універсальним листом, але воно буде трохи відрізнятися від того листа, який ми склали вище. Тут ми не будемо відправляти що-небудь по електронній пошті, щоб не уподібнюватися спамерам, а просто згенеруємо це повідомлення і виведемо його на екран браузера. Початковий варіант форми реєстрації ми вже наводили вище. Змінимо його таким чином, щоб кожен хто реєструється, міг вибрати скільки завгодно курсів для відвідування, і не будемо підтверджувати отримання реєстраційної форми.
		</p>
		<p>&lt;h2&gt; Форма для реєстрації студентів &lt;/ h2&gt;  &lt;form action="1.php" method=POST&gt;  Ім'я &lt;br&gt; &lt;input type = text name = "first_name"  value = "Ваше ім'я"&gt; &lt;br&gt;  Прізвище &lt;br&gt; &lt;input type=text name="last_name"&gt; &lt;br&gt;  E-mail &lt;br&gt; &lt;input type=text name="email"&gt; &lt;br&gt;  lt;p&gt; Виберіть курс, який ви б хотіли відвідувати: lt;br&gt;  lt;input type=checkbox name='kurs[]' value='PHP'&gt; PHP &lt;br&gt;  lt;input type=checkbox name='kurs[]' value='Lisp'&gt; Lisp &lt;br&gt;  lt;input type=checkbox name='kurs[]' value='Perl'&gt; Perl &lt;br&gt;  lt;input type=checkbox name='kurs[]' value='Unix'&gt; Unix &lt;br&gt;  lt;P&gt; Що ви хочете, щоб ми знали про вас? &lt;BR&gt;  lt;textarea name="comment" cols=32 rows=5&gt; &lt;/ textarea&gt;  lt;input type=submit value="Відправте"&gt;  lt;input type=reset value="Відмінити"&gt;  &lt;/ Form&gt;
		</p>
		
		<p>Тут все досить просто і зрозуміло. Єдине, що можна відзначити, - це спосіб передачі значень елемента checkbox. Коли ми пишемо в імені елемента kurs [], це означає, що перший зазначений елемент checkbox буде записаний в перший елемент масиву kurs, другий зазначений checkbox - у другий елемент масиву і т.д. Можна, звичайно, просто дати різні імена елементів checkbox, але це ускладнить обробку даних, якщо курсів буде багато.
		</p>
		
		<p>Скрипт, який все це буде розбирати і обробляти, називається 1.php (форма посилається саме на цей файл, що записано в її атрибуті action). За замовчуванням використовується для передачі метод GET, але ми вказали POST. За отриманими даними від зареєстрованої людини, скрипт генерує відповідне повідомлення. Якщо людина вибрала якісь курси, то йому виводиться повідомлення про час їх проведення та про лекторів, які їх читають. Якщо людина нічого не вибрав, то виводиться повідомлення про наступні збори заочної школи програмістів (ЗШП).
		</p>
		<p>&lt;?  // Створимо масиви відповідностей курс - час його  // Проведення та викладач курсу $times = array ("PHP" =&gt; "14.30", "Lisp" =&gt; "12.00",  "Perl" =&gt; "15.00", "Unix" =&gt; "14.00");  $lectors = array ("PHP" =&gt; "Василь Васильович",  "Lisp" =&gt; "Іван Іванович", "Perl" =&gt; "Петро Петрович", "Unix" =&gt; "Семен Семенович");  define ("SIGN", "З повагою, адміністрація");  // Визначаємо підпис листа як константу  define ("MEETING_TIME", "18.00");  // Задаємо час зборів студентів  $date = "12 травня"; // задаємо дату проведення лекцій  // Починаємо складати текст повідомлення  $str = "Здрастуйте, шановний". $_POST ["First_name"]. "". $_POST ["Last_name "]."!&lt;br&gt;";  $str .= "&lt;br&gt; Повідомляємо Вам, що";  $kurses = $_POST ["kurs"]; // збережемо в цій змінній  // Список вибраних курсів  if (!isset ($kurses)) {// якщо не обраний жоден курс  $event = "наступні збори студентів";  $str .= "$event відбудеться $date". MEETING_TIME. "&lt;br&gt;";  } Else {// якщо хоча б один курс вибраний  $event = "обрані Вами лекції відбудуться $date &lt;ul&gt;";  // Функція count обчислює число елементів у масиві  $lect = "";  for ($i = 0; $i &lt;count ( kurses); $i++) {  // Для кожного обраного курсу  $k = $kurses [$i]; // запам'ятовуємо назву курсу  $lect = $lect. "&lt;li&gt; Лекція з $k в $times [$k]";  // Складаємо повідомлення  $lect .= "(Ваш лектор, $lectors [$k])";  }  $event = $event. $lect. "&lt;/ Ul&gt;";  $str .= "$event";  }  $str .= "&lt;br&gt;". SIGN; // додаємо підпис  echo $str; // виводимо повідомлення на екран  ?&gt;
		</p>
		<h3>Суперглобальні масиви</h3>
		
		<p>Розглянемо роботу суперглобальних змінних в PHP.
		</p>
		
		<p>У PHP існує кілька суперглобальний змінних, а точніше суперглобальних масивів:
		</p>
		<ul>
			<li>$_SERVER</li>
			<li>$_GET</li>
			<li>$_POST</li>
			<li>$_FILES</li>
			<li>$_COOKIE</li>
			<li>$_SESSION</li>
			<li>$_REQUEST</li>
			<li>$_ENV</li>
		</ul><h3>Суперглобальний масив $_SERVER</h3>
		
		<p>Масив являє собою інформацію про заголовки, шляхи та розміщення скриптів. Записи в цьому масиві створюються веб-сервером. Не існує гарантій, що веб-сервер сформує цей масив з усіма параметрами. Даний масив містить такі елементи:
		</p>
		
		<p><strong>PHP_SELF:</strong> ім'я файлу, що в даний час виконується PHP-скриптом. Наприклад при виконанні скрипта <a href="http://phpprogs.ru/test/guestbook2/">http://phpprogs.ru/test/guestbook2/</a> даний елемент буде приймати значення / test/guestbook2/index.php.
		</p>
		
		<p><strong>argv:</strong> список аргументів, переданих скрипту. Якщо використовує в командному рядку, то отримуєте масив значень, якщо використовується $_GET, то буде містити рядок запиту.
		</p>
		
		<p><strong>argc:</strong> містить число параметрів переданих сценарієм (якщо запуск був з командного рядка).
		</p>
		
		<p><strong>GATEWAY_INTERFACE:</strong> параметр повертає версію CGI, яку використовує веб-сервер.
		</p>
		
		<p><strong>SERVER_ADDR:</strong> елемент містить IP адресу сервера, де виконується скрипт.
		</p>
		
		<p><strong>SERVER_NAME:</strong> елемент містить ім'я веб-сервера, де виконується скрипт.
		</p>
		
		<p><strong>SERVER_SOFTWARE:</strong> ідентифікаційний рядок веб-сервера, який повертається у відповідь при запитах.
		</p>
		
		<p><strong>SERVER_PROTOCOL: </strong>ім'я та версія протоколу HTTP.
		</p>
		
		<p><strong>REQUEST_METHOD: </strong>використовуваний метод запиту до веб-сервера (POST, GET, HEAD, PUT).
		</p>
		
		<p><strong>REQUEST_TIME: </strong>відмітка про час початку запиту (починаючи з PHP 5.1.0).
		</p>
		
		<p><strong>QUERY_STRING:</strong> рядок запиту до веб-сторінки, якщо вона існує, за допомогою якого був здійснений доступ до сторінки
		</p>
		
		<p><strong>DOCUMENT_ROOT:</strong> коренева директорія, з якої виконується скрипт.
		</p>
		
		<p><strong>HTTP_ACCEPT:</strong> зміст заголовка ACCEPT, якщо він є.
		</p>
		
		<p><strong>HTTP_ACCEPT_CHARSET:</strong> зміст заголовка ACCEPT-CHARSET, якщо він є. Наприклад 'iso-8859-1, *, utf-8'.
		</p>
		
		<p><strong>HTTP_ACCEPT_ENCODING:</strong> зміст заголовка ACCEPT-ENCODING, якщо він є. Наприклад 'gzip'.
		</p>
		
		<p><strong>HTTP_ACCEPT_LANGUAGE:</strong> зміст заголовка ACCEPT-LANGUAGE, якщо він є. Наприклад 'en'.
		</p>
		
		<p><strong>HTTP_ACCEPT_CONNECTION: </strong>зміст заголовка ACCEPT-CONNECTION, якщо він є. Наприклад 'Keep-Alive'.
		</p>
		
		<p><strong>HTTP_HOST:</strong> зміст заголовка HOST, тобто він є.
		</p>
		
		<p><strong>HTTP_REFERER: </strong>адреса сторінки, з якої на поточну сторінку перейшло програмне забезпечення користувача. Не всі ПЗ користувача передають цей параметр, а деякиі ПЗ навіть змінюють його. Отже, даному параметру довіряти не можна.
		</p>
		
		<p><strong>HTTP_USER_AGENT: </strong>цей параметр містить інформацію про клієнт користувача (ПО користувача), який звертається до сторінки. Наприклад 'Mozilla/4.5 [RU] (X11; U; Linux 2.2.9 i586). Також цю інформацію Ви можете отримати з функції get_browser ().
		</p>
		
		<p><strong>HTTPS:</strong> параметр містить інформацію, якщо запит був зроблений через HTTPS.
		</p>
		
		<p><strong>REMOTE_ADDR: </strong>IP-адреса користувача, з якого він переглядає сторінку.
		</p>
		
		<p><strong>REMOTE_HOST:</strong> ім'я хоста користувача, з якого він переглядає цю сторінку.
		</p>
		
		<p><strong>REMOTE_POST:</strong> порт, який використовується для з'єднання з веб-сервером.
		</p>
		
		<p><strong>SCRIPT_FILENAME:</strong> абсолютний шлях до поточного скрипта.
		</p>
		
		<p><strong>SERVER_ADMIN</strong>: значення SERVER_ADMIN, взяте з конфігураційного файлу Apache.
		</p>
		
		<p><strong>SERVER_PORT:</strong> порт веб-сервера, використаний для передачі даних по HTTP. За замовчуванням 80.
		</p>
		
		<p><strong>SERVER_SIGNATURE:</strong> рядок, що містить версію веб-сервера і ім'я віртуального хоста.
		</p>
		
		<p><strong>PATH_TRANSLATED: </strong>базовий шлях до поточного сценарія.
		</p>
		
		<p><strong>SCRIPT_NAME:</strong> містить шлях та ім'я поточного скрипта.
		</p>
		
		<p><strong>REQUEST_URI:</strong> URI для поточної сторінки.
		</p>
		
		<p><strong>PHP_AUTH_DIGEST:</strong> якщо PHP працює як модуль Apache, то параметр використовується як реквізити по протоколу HTTP для перевірки автентичності.
		</p>
		
		<p><strong>PHP_AUTH_USER:</strong> якщо PHP працює як модуль Apache або IIS, то параметр містить ім'я користувача при аутентифікації по протоколу HTTP.
		</p>
		
		<p><strong>PHP_AUTH_PW:</strong> якщо PHP працює як модуль Apache або IIS, то параметр містить пароль користувача при аутентифікації по протоколу HTTP.
		</p>
		
		<p><strong>AUTH_TYPE:</strong> якщо PHP працює як модуль Apache або IIS, то параметр містить тип аутентифікації по протоколу HTTP.
		</p>
		<h3>Суперглобальний масив $_GET</h3>
		
		<p>Масив $_GET представляє собою асоціативний масив елементів, переданих за допомогою HTTP GET запитів поточному PHP-скрипту. Немає необхідності оголошувати масив $_GET всередині функції користувача командою "global $_GET;", тому що даний масив є суперглобальний.
		</p>
		<h3>Суперглобальний масив $_POST</h3>
		
		<p>Масив $_POST представляє собою асоціативний масив елементів, переданих за допомогою HTTP POST запитів поточному PHP-скрипту. Немає необхідності оголошувати масив $_POST всередині функції користувача командою "global $_POST;", тому що даний масив є суперглобальний.
		</p>
		<h3>Суперглобальний масив $_FILES</h3>
		
		<p>Масив $_FILES представляє собою асоціативний масив елементів, переданих за допомогою HTTP POST запитів поточному PHP-скрипту. Немає необхідності оголошувати масив $_FILES всередині функції користувача командою "global $_FILES;", тому що даний масив є суперглобальний.
		</p>
		<h3>Суперглобальний масив $_COOKIE</h3>
		
		<p>Масив $_COOKIE представляє собою асоціативний масив елементів, переданих за допомогою HTTP COOKIE запитів поточному PHP-скрипту. Немає необхідності оголошувати масив $_COOKIE всередині функції користувача командою "global $_COOKIE;", тому що даний масив є суперглобальний.
		</p>
		<h3>Суперглобальний масив $_SESSION</h3>
		
		<p>Даний асоціативний масив містить змінні сесії, доступні для даного скрипта. Немає необхідності оголошувати масив $_SESSION всередині функції користувача командою "global $_SESSION;", тому що даний масив є суперглобальний.
		</p>
		<h3>Суперглобальний масив $ _REQUEST</h3>
		
		<p>Масив $_REQUEST є об'єднаним асоціативним масивом, який включає в себе масиви $_GET, $_POST, $_FILES. Немає необхідності оголошувати масив $_REQUEST всередині функції користувача командою "global $_REQUEST;", тому що даний масив є суперглобальний.
		</p>
		<h3>Суперглобальний масив $ _ENV</h3>
		
		<p>$_ENV Представляє собою асоціативний масив, який містить значення змінних з середовища, в якій працює інтерпретатор PHP. Немає необхідності оголошувати масив $_ENV всередині функції користувача командою "global $_ENV;", тому що даний масив є суперглобальний.
		</p>



	</div>
</body>
</html>