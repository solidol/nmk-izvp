<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<H2 id='L4'>Лекция 3. Массивы</h2>
<h4>Особенности массивов в PHP</h4>
<P>Своеобразие PHP в том, что в нём массивы обладают следующими свойствами.
<OL>
<LI>Все массивы - ассоциативные. 
<LI>Если ключи - целые числа, то массивом можно пользоваться как массивом с 
числовыми индексами. 
<LI>Элементы в массиве могут иметь разные типы.
<LI>Количество элементов в разных строках двумерного массива может быть
разным.
</ol>
<H4>Создание массива c числовыми индексами</h4>
<P>Создадим массив из одного элемента
</p><pre>
  $m0=array('весна');
  print "m0[0]=$m0[0]&lt;BR>"; // m0[0]=весна
//Можно создать массив, присвоив значение его элементу
  $m1[0] = 3; //$m1 - новый массив
  print "m1[0]=$m1[0]&lt;BR>"; //m1[0]=3
</pre><P id='M1'>Создадим массив из трёх элементов  .
</p><pre>
    $M1 = array(2,7,12);
</pre><P>Добавим к нему ещё 2 элемента
</p><pre>
    $M1[3] = 'Маша';
    $M1[4] = 2.71;
</pre><P>Добавим к нему сразу 7-й элемент, пропустив 5-й и 6-й, 
и распечатаем весь массив, считая, что в нём не 8, а 9 элементов:
</p><pre>
    $M1[7] = 100;
    for($i=0; $i&lt;=8; $i++)print "\$M1[$i] = $M1[$i]&lt;BR>";
  /*напечатается
    $M1[0] = 2
    $M1[1] = 7
    $M1[2] = 12
    $M1[3] = Маша
    $M1[4] = 2.71
    $M1[5] = 
    $M1[6] =
    $M1[7] = 100
    $M1[8] =
  В массиве 9 элементов, но 3 из них пустые.
  */
</pre>
<H4>Ассоциативные массивы и оператор <I>foreach</i></h4>
<P>Создадим очевидный ассоциативный массив и распечатаем его.
</p><PRE>
    $AssM['сезон'] = 'весна';
    $AssM['месяц'] = 'май';
    $AssM['число'] = 1;
    foreach($AssM as $kluch => $znach) print "$kluch - $znach&lt;BR>;
    /* Напечатается
       сезон - весна
       месяц - май
       число - 1
   */
</pre><P>Часто нужно перебрать все  элементы массив, длина которого неизвестна, 
например, при чтении в массив текстового файла. Для этой цели служит оператор <B>foreach</b>.
Существую две разновидности foreach. Приведённый выше оператор служит для перебора массива,
рассматриваемого, как ассоциативный. Распечатаем массив $AssM, как массив с числовыми 
индексами, используя другую разновидность foreach.
</p><PRE>
     foreach($AssM as $znach) print "$znach&lt;BR>";
      /* Напечатается
        весна
        май
        1
     */
</pre><P id='cveta'>Более нагляден следующий способ создания ассоциативного массива:
</p><PRE>
    $cveta=array(
                 "red"=>"Красный",
                 "yellow"=>"Жёлтый",
                 "green"=>"Зеленый",
                 "blue"=>"Синий",
                 "maroon"=>"Каштановый"
                );   
</pre><P>Распечатаем как ассоциативный  массив <A href="#M1">$M1</a>, который
создавался как массив с числовыми индексами .  
</p><PRE>
 foreach($M1 as $kluch => $znach) print "$kluch - $znach&lt;BR>;
    /* Напечатается
      0 - 2
      1 - 7
      2 - 12
      3 - Маша
      4 - 2.71
      7 - 100
	*/
</pre>
<H4>Операции с массивами</h4>
<UL>
<LI> +    - объединение по ключам;
<LI> ==   - true, если $a и $b содержат одинаковые элементы;
<LI> ===  - true, если $a и $b содержат одинаковые элементы,
расположенные в одинаковом порядке;
<LI> !=   - true, если в $a и $b есть неодинаковые элементы;
<LI> <>   - то же, что и !=
<LI> !==  - true, если $a и $b содержат одинаковые элементы, 
но порядок элементов разный;
</ul>
<P><B>Примеры</b>
</p><P><I>Объединение по ключам</i>. 
</p><PRE>
   $a = array(1,2);
   $b = array(3,4);
   //У этих массивов ключи имеют одинаковые значения 0 и 1
   $c = $a + $b;
   foreach($c as $x)print "$x ";
   // Результат 1 2
   // Элементы с повторяющимися ключами берутся только один раз
   //
   $d = array(2 => 'a', 3 => 'b', 8 => 'c')
   // Ключи в $a - 0, 1; ключи в $d - 2, 3, 8. Совпадающих ключей нет
   $c = $a + $d; //$c=(1,2,'a','b','c')
</pre><P><I>Сравнение массивов</i>
</p><PRE>
   $b = $a; //Копирование массива. $b и $a одинаковые массивы
   $g = $a == $b; //$g = 1, т.е. "истина"
   $g = $a === $b; //$g = 1, т.е. "истина"
   $c = array(0 => 2, 1 => 1);
   $g = $a ==  $c; //$g = 1, т.е. "истина"
   $g = $a ===  $c; //$g = 0, т.е. "ложь", не идентично
</pre>
<H4>Функции, для работы с массивами</h4>
<P>В PHP огромное количество встроенных функций. В руководстве по PHP, 
выпущенном в 2005 году, описывается 5211 функций. Только на просмотр такого
количества нужно 5211/4/8 = 163 рабочих дня, если на каждую функцию тратить
по 15 минут. И это многообразие всё время пополняется. Функций для работы с 
массивами - 80. Рассмотрим лишь некоторые из них.
</p><P><B>count(имя_массива)</b> - функция, возвращающая количество элементов 
в массиве. Подсчитаем длину рассмотренного выше <A href="#M1">массива $M1</a>:
</p><PRE>
    $L = count($M1); //$L=6
</pre><P>Из примера следует, что функция count возвращает количество непустых
элементов массива.
</p><P><B>Функции сортировки</b>
<UL>
<LI>sort(имя_массива) - сортировка по возрастанию элементов массива с числовыми 
индексами.	
<LI>asort(имя_массива) - сортировка ассоциативного массива по возрастанию значений.
<LI>ksort(имя_массива) - сортировка ассоциативного массива по возрастанию ключей.
<LI>rsort(имя_массива) - сортировка по убыванию элементов массива с числовыми 
индексами.	
<LI>arsort(имя_массива) - сортировка ассоциативного массива по убыванию значений.
<LI>krsort(имя_массива) - сортировка ассоциативного массива по убыванию ключей.
<LI>usort(имя_массива) - определяемая пользователем функция сортировки массива с 
числовыми индексами.	
<LI>uasort(имя_массива) - определяемая пользователем функция сортировки 
ассоциативного массива по значениям.
<LI>uksort(имя_массива) - определяемая пользователем функция сортировки 
ассоциативного массива по ключам.
</ul>
<P><B>Примеры</b>
</p><P>Cортировка по возрастанию элементов массива 
  с числовыми  индексами.
</p><PRE>
     <span class='g'>sort($M1);</span>
     for($i=0; $i&lt;9; $i++)print "\$M1[$i] = $M1[$i]&ltBR>";
   /*Результат сортировки
     $M1[0] = Маша
     $M1[1] = 2
     $M1[2] = 2.71
     $M1[3] = 7
     $M1[4] = 12
     $M1[5] = 100
     $M1[6] =
     $M1[7] =
     $M1[8] = 
  */
</pre><P>Cортировка ассоциативного массива <A href=#cveta>$cveta</a>  по возрастанию значений
</p><PRE>
   <span class='g'>asort($cveta);</span>
   foreach($cveta as $kluch=>$znach)
        print "$kluch - $znach&ltBR>";
  /*Результат сортировки 
    yellow - Жёлтый
    green -  Зеленый
    maroon - Каштановый
    red -    Красный
    blue -   Синий
  */
</pre><P>Cортировка ассоциативного  массива $cveta по возрастанию ключей
</p><PRE>
   <span class='g'>ksort($cveta);</span>
   foreach($cveta as $kluch=>$znach)
        print "$kluch - $znach&ltBR>";
  /*Результат сортировки   
     blue -   Синий
     green -  Зеленый
     maroon - Каштановый
     red -    Красный
     yellow - Жёлтый
  */
</pre><P><B>Функции для добавления и удаления элементов массива</b>
</p><UL>
<LI>array_pad - увеличить размер массива до заданной величины.
<LI>array_pop - извлечь последний элемент массива.
<LI>array_push -  добавить один или несколько элементов в конец массива.
<LI>array_shift -  извлечь первый элемент массива.
<LI>array_unshift - добавить один или несколько элементов в начало массива. 
</ul>
<P>Часто применяется функция <I>array_shift(array)</i>, которая извлекает 
значение первого элемента  массива <I>array</i> и возвращает это значение, 
сокращая размер <I>array</i> на один элемент. Все числовые ключи будут 
изменены таким образом, что нумерация массива начнётся с нуля, в то время 
как строковые ключи останутся прежними. Если array пуст (или не является 
массивом), будет возвращён <I>NULL</i>.
</p><P>Эту функцию удобно использовать для удаления из массива и запоминания в отдельной переменной
шапки таблицы.
</p><P><B>Пример</b>
</p><PRE>
  $Arr = Array('a'=> 'alfa','b'=> 'beta','c'=> 'gamma');
  $a1 = array_shift($Arr);
  print_r ($Arr); //print_r - функция для отладочной печати
  print "\$a1=$a1&lt;BR>";
//Результат
// Array ( [b] => beta [c] => gamma ) 
//  $a1=alfa  
</pre>
<H4>Двумерные массивы</h4>
<P>Создадим двумерный массив
</p><pre id='M2'>
$M2= array(
          array(1,2,3),
          array(4,5,6,'семь'),
          array('a','b','c'),
         );
</pre><P>Можно создавать двумерный массив поэлементно.
</p><pre>
   $M3[0][0]='alfa';
   $M3[0][1]='beta';
</pre><P>Подсчитаем количество строк в массиве $M2 и количество
элементов в строке M2[1].
</p><pre>
    $Lrow = count($M2); // $Lrow = 3
    $Lcol = count($M2[1]); // $Lcol = 4
</pre><P>Распечатаем двумерный массив $M2.
</p><pre>
   foreach($M2 as $row)
   {  foreach ($row as $el)
      { print "$el ";
      }
      print '&lt;BR>';
   }
  /* Результат
     1 2 3
     4 5 6 семь
     a b c 
  */
</pre><P>Создадим явный ассоциативный массив, добавив в $M3 строку
</p><pre>
   $M3['odin'][0] = 'два';
   $M3['odin'][1] = 'три';
   print 'L='.count($M3)." \$M3['odin'][1] = ".$M3['odin'][1]."&lt;BR>";
 /* Результат
    L=2 $M3['odin'][1] = три
 */
</pre><P><B>Пример сортировки двумерного массива с помощью функции usort().</B><br>
Сортируется <A href=#M2>массив $M2</a> по второму столбцу (с индексом 1) в порядке возрастания
</p><PRE>
 usort($M2, 'compare1');
 foreach($M2 as $row)
 {  foreach ($row as $el)
    { print "$el ";
    }
    print '&lt;BR>';
 }
/* Результат
  a b c
  1 2 3
  4 5 6 семь 
*/
 function compare1($x,$y) //Сортировка по возрастанию
 {                        //$x и $y - две соседние строки
    if($x[1] == $y[1]) return 0; //порядок не определён
    elseif(($x[1] > $y[1]) return 0; //первым $y[1]
    else                   return 1; //первым $x[1]
  }
</pre><H4>Массив ассоциативный или с числовыми индексами?</H4>
<P style="text-align:right; font-family:'courier new'; font-size:12pt;">
Если где-нибудь что-нибудь убавится,<BR>
то где-то что-то прибавится.<BR>
Закон сохранения</p>
<P>В PHP все массивы ассоциативные, то есть, форально в PHP нет,
в отличие от большинства языков высокого уровня,
массивов с числовыми индексами. Согласно приведённому в шутливой
фоме в эпиграфе данного параграфа закону сохранения, такое решение
должно привести и к положительным и к отрицательным последствиям.
<P><I>Достоинства ассоциативных массивов.</i> Применение ассоциативных 
массивов вместо массивов с числовыми индексами в некоторых случаях 
позволяет сильно упростить программу, например программу обработки 
сообщений в узле связи. Следует отметить, что такие случаи на практике 
встречаются нечасто.
<P><I>Недостатки ассоциативных массивов</i> по сравнению с массивами с
числовыми индексами:
</p><UL>
<LI>занимают больше места в памяти;
<LI>большее время выборки элемента;
<LI>очень сложные, скрытые от прикладной программы, алгоритмы 
записи и выборки.
</ul>
<P>Рассмотрим пример, в котором будем испльзовать массив <I>$MC</i>
как массив с числовыми индексами. Создадим два первых элемента:
</p><PRE>
$MC[0] = 'синий';
$MC[1] = 'зелёный';
</pre><P>Подсчитаем количество элементов в массиве и распечатаем его
с помощью оператора <I>for</i>, используемого только в случае, когда
массив рассматривается как масссив с числовыми индекксами.
</p><PRE>
$L=count($MC);
for ($i=0; $i &lt; $L; $i++) print "$i $MC[$i]&lt;BR>";
/* Результат
0  синий
1  зелёный
*/
</pre><P>Предположим, что программа, в которой используется массив <I>$MC</i>,
большая, разрабатывается долго и программист в какой-то момент забыл, что
использует <I>$MC</i> как масссив с числовыми индексами, и добавил новый 
элемент с текстовым ключом:
</p><PRE>
$MC['red'] = 'Красный';
</pre><P>Снова подсчитаем количество элементов и распечатаем массив <I>$MC</i>
</p><PRE>
$L=count($MC);
for ($i=0; $i < $L; $i++) print "$i $MC[$i]&lt;BR>";
/* Результат
0  синий
1  зелёный
2
*/
</pre><P>Так как мы условились, что в рассматриваемой программе <I>$MC</i> 
используется только как масссив с числовыми индексами, то элемент 
<I>$MC['red']</i> со значением 'Красный' никогда не будет использоваться. 
Его, как бы, нет. Такая ошибка очень трудно обнаруживается, но возникла она
вследствии упрощения языка. В одном месте убавилось, в другом прибавилось,
причём очень неприятно прибавилось.
</p><P><B>Пустые и полупустые элементы массива</b>
</p><P>Элементы используемых в большинстве языков программирования настоящих массивов с 
числовыми индексами располагаются в последовательных ячейках памяти. Если массив, состоящий из
<I>m</i> элементов, расположен, начиная с ячейки с адресом <I>n</i>, то адрес <I>i-го</i>
элемента равен <I>n + i</i>. Таким образом, для того чтобы найти <I>i-й</i> элемент массива,
нужно хранить только адрес начала и длину массива с числовыми индексами. 
Индексы элементов такого массива , в отличие от ключей ассоциативного 
массива, хранить в памяти ЭВМ не нужно.
<P>Любая ячейка памяти в любой момент времени содержит какой-то
набор нулей и единиц, то есть, физически пустых ячеек быть не может.
Семантически (логически) элементы массива могут быть пустыми, например.
в <I>i-й</i> элемент массива цен не занесена цена товара. Для указания,
что элемент массива пуст, служит специальная величина <I>NULL</i>, хранимая в этом
элементе.
</p><P>Раасмотрим, что понимается под "пустым" элементом массива в PHP. Создадим
массив $M:
</p><PRE>
$M[0]=100;
$M[1]=200;
$M['red']='красный';
$M[3]=NULL;
$M[4]=FAlSE;
$M[5]='';
$M[8]=300;
</pre><P>Распечатаем этот массив тремя способами.<BR>
1. Как массив с числовыми индексами.
</p><PRE>
for ($i=0; $i < 9; $i++) print "$i $M[$i]&lt;BR>";

Результат
0 100
1 200
2
3
4
5
6
7
8 300
</pre><P>Элемент с ключом 'red' не виден, элементы со значениями <I>NULL, FALSE, '' (две кавычки)</i>
и  элементы <I>$M[2], $M[6], $M[7]</i> - пустые
</p><P>2. С помощью оператора <I>foreach</i> распечатаем только значения элементов.
</p><PRE>
$i=0;
foreach(($M) as $x ) print $i++." $x&lt;BR>";

Результат
0 100
1 200
2 красный
3
4
5
6 300
</pre><P>3. С помощью оператора <I>foreach</i> распечатаем все элементы массива и ключи.
</p><PRE>
foreach(($M) as $k => $z ) print "$k $z&lt;BR>";

Результат
<B>Ключ  Значение</b>
 0       100
 1       200
 red     красный
 3
 4
 5
 8       300
</pre><P>Из сравненния действительного содержимого массива <I>$M</i> с
результатами вывода на печать следует, что элементы с индексами
2, 6, 7 не существуют, а элементы 3, 4, 5 имеют ключи, но не имеют
значений.
</p><P>В этом коротком обзоре перечислены далеко не все проблемы,
возникающие из-за отсутствия в <I>PHP</i> явного типа массивов с
числовыми индексами.
</body>
</html>