<!DOCTYPE html>
<html>
<head>
	<title>Інструментальні засоби візуального програмування. Лекція №1 </title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
	<div class="paper">
		<div id="colontitle">Інструментальні засоби візуального програмування. Лекція №1 </div>
		<h1>Вступ до web-програмування. Застосування CGI</h1>
		

		<p>
			Обмен данными в Web-технологии подразделяется в соответствии с типами методов доступа протокола HTTP и видами запросов в спецификации CGI.
		</p>
		<p>
			Основных методов доступа два: GET и POST. Помимо них часто используются HEAD и PUT.
		</p>
		<p>
			Виды запросов CGI разделяют на два основных MIME-типа: application/x-www-form-urlencoded и multipart/form-data. Второй тип запроса специально создан для передачи больших внешних файлов.
		</p>
		<p>
			Эту классификацию можно представить в виде таблицы:
		</p>

		<table border="0" class="xml_table" cellpadding="2" cellspacing="1">
			<tr>
				<th colspan="2" bgcolor="#d8d8d8">Метод</th>
				<th bgcolor="#d8d8d8"> Клиент --&gt; Сервер</th>
				<th bgcolor="#d8d8d8">Клиент &lt;-- Сервер</th>
			</tr>
			<tr>
				<td rowspan="3" bgcolor="#eaeaea" valign="top">GET</td>
				<td bgcolor="#eaeaea" valign="top">По умолчанию</td>
				<td bgcolor="#eaeaea" valign="top">Только HTTP-заголовок</td>
				<td bgcolor="#eaeaea" valign="top">HTTP-заголовок и страница, как тело HTTP-сообщения</td>
			</tr>
			<tr>
				<td bgcolor="#eaeaea" valign="top">isindex</td>
				<td bgcolor="#eaeaea" valign="top">Только HTTP-заголовок (список ключевых слов включен в URL. Слова разделены символом "+". Кодирования кириллицы не производится)</td>
				<td bgcolor="#eaeaea" valign="top">HTTP-заголовок и страница, как тело HTTP-сообщения</td>
			</tr>
			<tr>
				<td bgcolor="#eaeaea" valign="top">form-urlencoded</td>
				<td bgcolor="#eaeaea" valign="top">Только HTTP-заголовок (данные из формы включены в URL страницы. Производится кодирование специальных символов и кириллицы) и тело HTTP-сообщения</td>
				<td bgcolor="#eaeaea" valign="top">HTTP-заголовок и страница, как тело HTTP-сообщения</td>
			</tr>
			<tr>
				<td rowspan="2" bgcolor="#eaeaea" valign="top">POST</td>
				<td bgcolor="#eaeaea" valign="top">form-urlencoded</td>
				<td bgcolor="#eaeaea" valign="top">Только HTTP-заголовок (данные из формы включены в URL страницы. Производится кодирование специальных символов и кириллицы) и тело HTTP-сообщения</td>
				<td bgcolor="#eaeaea" valign="top">HTTP-заголовок и страница, как тело HTTP-сообщения</td>
			</tr>
			<tr>
				<td bgcolor="#eaeaea" valign="top">form-data</td>
				<td bgcolor="#eaeaea" valign="top">HTTP-заголовок и составное тело HTTP-сообщения. Первая часть тела — данные из формы, для которых производится кодирование, вторая часть тела — присоединенный файл как он есть</td>
				<td bgcolor="#eaeaea" valign="top">HTTP-заголовок и страница, как тело HTTP-сообщения</td>
			</tr>
			<tr>
				<td colspan="2" bgcolor="#eaeaea" valign="top">PUT</td>
				<td bgcolor="#eaeaea" valign="top">HTTP-заголовок и документ, как тело HTTP-сообщения</td>
				<td bgcolor="#eaeaea" valign="top">HTTP-заголовок. В качестве тела можно передать комментарий к коду возврата</td>
			</tr>
			<tr>
				<td colspan="2" bgcolor="#eaeaea" valign="top">HEAD</td>
				<td bgcolor="#eaeaea" valign="top">HTTP-заголовок</td>
				<td bgcolor="#eaeaea" valign="top">HTTP-заголовок</td>
			</tr>
		</table>

<h2>HyperText Transfer Protocol</h2>

<p>
Все данные в рамках Web-технологии передаются по протоколу HTTР. Исключение составляет обмен с использованием программирования на Java или обмен из Plugin-приложений. Учитывая реальный объем трафика, который передается в рамках Web-обмена по HTTP, мы будем рассматривать только этот протокол. При этом мы остановимся на таких вопросах, как:
</p>

<ul>
    <li>общая структура сообщений;</li>
    <li>методы доступа;</li>
    <li>оптимизация обменов.</li>
</ul>

<h3>Общая структура сообщений</h3>

<p>
HTTP — это протокол прикладного уровня. Он ориентирован на модель обмена "клиент-сервер". Клиент и сервер обмениваются фрагментами данных, которые называются HTTP-сообщениями. Сообщения, отправляемые клиентом серверу, называют запросами, а сообщения, отправляемые сервером клиенту — откликами. Сообщение может состоять из двух частей: заголовка и тела. Тело от заголовка отделяется пустой строкой.</p>
<p>
Заголовок содержит служебную информацию, необходимую для обработки тела сообщения или управления обменом. Заголовок состоит из директив заголовка, которые обычно записываются каждая на новой строке.
</p>
<p>
Тело сообщения не является обязательным, в отличие от заголовка сообщения. Оно может содержать текст, графику, аудио- или видеоинформацию.
</p>
<p>
Ниже приведен HTTP-запрос:
</p>
<pre>
GET / HTTP/1.0
Accept: image/jpeg
пустая строка
</pre>
<p>
И отклик:
</p>
<pre>
HTTP/1.0 200 OK
Date: Fri, 24 Jul 1998 21:30:51 GMT
Server: Apache/1.2.5
Content-type: text/html
Content-length: 21345
пустая строка
<HTML>
...
</HTML>
</pre>
<p>
Текст "пустая строка" — это просто обозначение наличия пустой строки, которая отделяет заголовок HTTP-сообщения от его тела.
</p>
<p>
Сервер, принимая запрос от клиента, часть информации заголовка HTTP-запроса преобразует в переменные окружения, которые доступны для анализа CGI-скриптом. Если запрос имеет тело, то оно становится доступным скрипту через поток стандартного ввода.
Методы доступа
</p>
<p>
Самой главной директивой HTTP-запроса является метод доступа. Он указывается первым словом в первой строке запроса. В нашем примере это GET. Различают четыре основных метода доступа:
</p>
<ul>
    <li>GET;</li>
    <li>HEAD;</li>
    <li>POST;</li>
    <li>PUT.</li>
</ul>
<p>
Кроме этих четырех методов существует еще около пяти дополнительных методов доступа, но они используются редко.
</p>

<h3>Метод GET</h3>
<p>
Метод GET применяется клиентом при запросе к серверу по умолчанию. В этом случае клиент сообщает адрес ресурса (URL), который он хочет получить, версию протокола HTTP, поддерживаемые им MIME-типы документов, версию и название клиентского программного обеспечения. Все эти параметры указываются в заголовке HTTP-запроса. Тело в запросе не передается.
</p>
<p>
В ответ сервер сообщает версию HTTP-протокола, код возврата, тип содержания тела сообщения, размер тела сообщения и ряд других необязательных директив HTTP-заголовка. Сам ресурс, обычно HTML-страница, передается в теле отклика.
</p>
<h3>Метод HEAD</h3>

<p>
Метод HEAD используется для уменьшения обменов при работе по протоколу HTTP. Он аналогичен методу GET за исключением того, что в отклике тело сообщения не передается. Данный метод используется для проверки времени последней модификации ресурса и срока годности кэшированных ресурсов, а также при использовании программ сканирования ресурсов World Wide Web. Одним словом, метод HEAD предназначен для уменьшения объема передаваемой по сети информации в рамках HTTP-обмена.
</p>

<h3>Метод POST</h3>
<p>
Метод POST — это альтернатива методу GET. При обмене данными по методу POST в запросе клиента присутствует тело HTTP-сообщения. Это тело может формироваться из данных, которые вводятся в HTML-форме, или из присоединенного внешнего файла. В отклике, как правило, присутствует и заголовок, и тело HTTP-сообщения. Чтобы инициировать обмен по методу POST, в атрибуте METHOD контейнера FORM следует указать значение " post ".
</p>

<h3>Метод PUT</h3>
<p>
Метод PUT используется для публикации HTML-страниц в каталоге HTTP-сервера. При передаче данных от клиента к серверу в сообщении присутствует и заголовок сообщения, в котором указан URL данного ресурса, и тело — содержание размещаемого ресурса.
</p>
<p>
В отклике тело ресурса обычно не передается, а в заголовке сообщения указывается код возврата, который определяет успешное или неуспешное размещение ресурса.
</p>

<h2>Спецификация Common Gateway Interface</h2>
<p>
Данная спецификация определяет стандартный способ обмена данными между прикладной программой и HTTP-сервером. Спецификация была предложена для сервера NCSA и является основным средством расширения возможностей обработки запросов клиентов HTTP-сервером.
</p>
<p>
В CGI имеет смысл выделить следующие основные моменты:
</p>
<ul>
    <li>понятие CGI-скрипта ;</li>
    <li>типы запросов;</li>
    <li>механизмы приема данных скриптом;</li>
    <li>механизм генерации отклика скриптом.</li>
</ul>
<p>
Основное назначение CGI — обработка данных из HTML-форм. В настоящее время область применения CGI гораздо шире.
Понятие CGI-скрипта
</p>
<p>
CGI-скриптом называют программу, написанную на любом языке программирования или командном языке, которая осуществляет обмен данными с HTTP-сервером в соответствии со спецификацией Common Gateway Interface .
</p>
<p>
Наиболее популярными языками для разработки скриптов являются Perl и С.
</p>
<h2>Типы запросов</h2>

<p>
Различают два типа запросов к CGI-скриптам: по методу GET и по методу POST. В свою очередь, запросы по методу GET подразделяются на запросы по типам кодирования: isindex и form-urlencoded, а запросы по методу POST — multipart/form-data и form-urlencoded.
</p>
<p>
В запросах по методу GET данные от клиента передаются скрипту в переменной окружения QUERY_STRING. В запросах по методу POST данные из формы передаются в потоке стандартного ввода скрипта. При передаче через поток стандартного ввода в переменной окружения CONTENT_LENGTH указывается число передаваемых символов.
</p>
<p>
Запрос типа ISINDEX — это запрос вида:
</p>
<pre>
http://intuit.ru/somthing-cgi/cgi-script?word1+word2+word3
</pre>
<p>
Главным здесь является список слов после символа "?". Слова перечисляются через символ "+" и для кириллицы в шестнадцатеричные последовательности не кодируются. Последовательность слов после символа "?" будет размещена в переменной окружения QUERY_STRING.
</p>
<p>
Запрос типа form-urlencoded — это запрос вида:
</p>
<pre>
http://intuit.ru/somthing-cgi/cgi-script?field=word1&field2=word2
</pre>
<p>
Данные формы записываются в виде пар "имя_поля=значение", которые разделены символом "&".
</p>
<p>
Приведенный пример — это обращение к скрипту по методу GET. Все символы после "?" попадут в переменную окружения QUERY_STRING. При этом если в значениях полей появляется кириллица или специальные символы, то они заменяются шестнадцатиричным кодом символа, который следует за символом "%".
</p>
<p>
При обращении к скрипту по методу POST данные после символа "?" не будут размещаться в QUERY_STRING, а будут направлены в поток стандартного ввода скрипта. В этом случае количество символов в потоке стандартного ввода скрипта будет указано в переменной окружения CONTENT_LENGTH.
</p>
<p>
При запросе типа multipart/form-data применяется составное тело HTTP-сообщения, которое представляет собой данные, введенные в форме, и данные присоединенного внешнего файла. Это тело помещается в поток стандартного ввода скрипта. При этом к данным формы применяется кодирование как в form-urlencoded, а данные внешнего файла передаются как есть.
Механизмы приема данных скриптом
</p>
<p>
Скрипт может принять данные от сервера тремя способами:
</p>
<ul>
    <li>через переменные окружения;</li>
    <li>через аргументы командной строки;</li>
    <li>через поток стандартного ввода.</li>
</ul>
<p>
При описании этих механизмов будем считать, что речь идет об обмене данными с сервером Apache для платформы Unix.</p>
<h2>Переменные окружения</h2>

<p>
При вызове скрипта сервер выполняет системные вызовы fork и exec. При этом он создает среду выполнения скрипта, определяя ее переменные. В спецификации CGI определены 22 переменные окружения. При обращении к скрипту разными методами и из различных контекстов реальные значения принимают разные совокупности этих переменных. Например, при обращении по методу POST переменная QUERY_STRING не имеет значения, а по методу GET — имеет. Другой пример — переменная окружения HTTP_REFERER. При переходе по гипертекстовой ссылке она определена, а если перейти по значению поля location или через JavaScript-программу, то HTTP_REFERER определена не будет.
</p>
<p>
Получить доступ к переменным окружения можно в зависимости от языка программирования следующим образом:
</p>
<pre>
#Perl
$a = $ENV{CONTENT_LENGTH};
...
// C
a = getenv("CONTENT_LENGTH");
</pre>
<p>
В случае доступа к скрипту по методу GET данные, которые передаются скрипту, размещаются в переменной окружения QUERY_STRING.
Аргументы командной строки
</p>
<p>
Как ни странно звучит, но у CGI-скрипта может быть такой элемент операционного окружения как командная строка. Это не означает, что скрипт реально можно вызвать из командной строки через сервер. Тем не менее получить доступ к содержанию командной строки скрипта можно с помощью тех же функций, что и при вызове его из-под интерактивной оболочки:
</p>
<pre>
#Perl
foreach $a (@ARGV)
{
print $a,"\n";
}
</pre>

<pre>
// C
void main(argc,argv)
int argc;
char *argv[];
{
int i;
for(i=0;i < argc;i++)
{
printf("%s\n",argv[i]);
}
}
</pre>
<p>
В обоих примерах показана распечатка аргументов командной строки для программ на Perl и C соответственно.
</p>
<p>
Аргументы командной строки появляются только в запросах типа ISINDEX.
</p>
<h2>Поток стандартного ввода</h2>
<p>
Ввод данных в скрипт через поток стандартного ввода осуществляется только при использовании метода доступа к ресурсу (скрипту) POST. При этом в переменную окружения CONTENT_LENGTH помещается число символов, которое необходимо считать из потока стандартного ввода скрипта, а в переменную окружения CONTENT_TYPE помещается тип кодирования данных, которые считываются из потока стандартного ввода.
</p>
<p>
При посимвольном считывании в C можно применить, например, такой фрагмент кода:
</p>
<pre>
int n;
char *buf;
n= atoi(getenv("CONTENT_LENGTH"));
buf = (char *) malloc(n+1);
memset(buf,'\000',n+1);
for(i=0;i< n;i++)
{
buf[i]=getchar();
}

free(buf);
</pre>
<p>
В данном фрагменте применено динамическое размещение памяти в скрипте, поэтому при выходе из него память следует освободить. Вообще говоря, память будет автоматически освобождена операционной системой после завершения скрипта. Однако, если переносить скрипт на спецификацию FCGI (Fast CGI), что требует минимума переделок, из-за неаккуратной работы с памятью могут возникнуть проблемы.
</p>

<h2>Механизм генерации отклика скриптом</h2>
<p>
Существует только один способ вернуть данные серверу и, соответственно, браузеру пользователя — писать в поток стандартного вывода (STDOUT). При этом скрипт должен формировать HTTP-сообщение.
</p>
<p>
Сначала выводятся директивы HTTP-заголовка. В минимальном варианте это либо
</p>
<pre>
Content-type: text/html,
</pre>
<p>
либо
</p>
<pre>
Location: http://intuit.ru/
</pre>
<p>
В первом случае определяется тип тела HTTP-сообщения, а во втором осуществляется перенаправление запроса.
</p>
<p>
После заголовка генерируется отклик в виде тела HTTP-сообщения, которое должно быть отделено от заголовка пустой строкой:
</p>
<pre>
#!/bin/sh
echo Content-type: text/plain
echo
echo Hello
</pre>
<p>
В данном случае используется командный интерпретатор sh.
</p>
<p>
Если скрипт начинает формирование заголовка с директивы версии HTTP-протокола, то сервер не анализирует отклик и передает его как есть. Если в заголовке, сгенерированном скриптом, эта директива отсутствует, то сервер считает, что заголовок неполный, и вставляет в него дополнительные директивы.
</p>


<h2>Общая структура C-скрипта</h2>
<p>
Скрипт на языке C ничем не отличается от обычной C-программы. Собственно, это набор процедур, среди которых есть главная процедура. Этой главной процедуре передается управление при загрузке программы в оперативную память. Главная процедура контролирует вызов других процедур и весь ход выполнения программы. Простой скрипт — это одна главная процедура.
</p>
<p>
При разработке С-скрипта следует всегда помнить, что в отличие от скрипта на Bash и Perl, С-скрипт, прежде чем выполнить, нужно еще и откомпилировать, т.е. превратить в исполняемый компьютером код. Если в системе нет компилятора для C, то программировать С-скрипты будет довольно сложно.
</p>
<p>
Синтаксически главная процедура выглядит следующим образом:
</p>
<pre>
#include "stdlib.h"
#include "stdio.h"
void main(argc,argv,env)
int *argc;
char *argv[];
char *env[];
{
/* тело программы */
}
</pre>
<p>
В этом фрагменте представлены все основные элементы программирования CGI-скриптов на С. Строки в начале программы ( #include... ) позволяют включить в текст программы декларации (описатели) стандартных функций. Строка " void main..." — это объявление главной процедуры. В качестве параметров в данную процедуру (функцию) передаются:
</p>
<ol>
    <li>число аргументов командной строки — argc ;</li>
    <li>указатель на массив аргументов командной строки — argv ;</li>
    <li>указатель на массив переменных окружения — env.</li>
</ol>
<p>
Само тело программы помещается между символами фигурных скобок "{...}". Фраза "тело программы" размещена между парой "/* ... */". Это комментарий. Сама программа на С состоит из операторов. Операторы могут быть простые и составные. Простые операторы – это, например, оператор присваивания. Составной оператор — это блок. Блок представляет собой последовательность операторов, заключенную в фигурные скобки "{...}". В конце простого оператора должен стоять символ ";". В нашем примере объявление (декларирование) переменных перед блоком тела программы — это последовательность простых операторов.
</p>
<p>
Про С часто говорят, что в языке только пять операторов, а все остальное — это библиотека стандартных функций. Операторов в нем, конечно, больше, но такая характеристика в целом верна.
Стандартный поток вывода
</p>
<p>
Стандартный поток вывода в С ассоциируется с дескриптором STDOUT. Самым распространенным способом записи данных в этот поток является функция форматного вывода printf. Если скрипт должен что-то передать браузеру пользователя, то первое, что нужно сделать — это применить printf для формирования HTTP-заголовка:
</p>
<pre>
main()
{
printf("Content-type: text/html\n\n");
printf("C и CGI");
}
</pre>
<p>
Первый вызов printf формирует заголовок — определяет тип тела HTTP-отклика, а второй вызов формирует заглавие первого уровня в HTML-документе. В общем случае у функции printf три аргумента: printf(FILE,"format",VARS_LIST); FILE — дескриптор файла, "format" — формат вывода данных, VARS_LIST — список переменных, чьи значения подлежат выводу. Если дескриптор файла опущен, то вывод направляется в поток стандартного вывода. Список переменных указывается в том случае, если в формате вывода есть шаблоны вывода для переменных из этого списка.
</p>
<p>
Для каждого типа данных в С существует свой шаблон вывода. Перечислим только некоторые из них:
</p>
<ol>
<li>%d — вывод целого числа;</li>
<li>%s — вывод массива символов (строки);</li>
<li>%f — вывод вещественного числа;</li>
<li>%x — вывод целого числа в шестнадцатеричном виде.</li>
</ol>
<p>
Для того, чтобы распечатать аргументы командной строки, можно применить следующий формат:
</p>
<pre>
int i;
...
for(i=0;i< argc;i++)
{
printf("arg[%d]=%s\n",i,argv[i]);
}
</pre>
<p>
В данном случае переменная цикла i — это целая константа, поэтому в квадратных скобках указано [%d]. Второй аргумент списка переменных — указатель на массив символов (строка, содержащая значение аргумента командной строки ), поэтому после знака равенства ("=") применен шаблон вывода массива символов %s.
Переменные окружения
</p>
<p>
Третий аргумент главной процедуры — указатель на массив переменных окружения, каждый элемент которого представляет собой строковую константу вида "имя-значение". Неудобство работы с этим массивом заключается в том, что заранее не известно, сколько элементов он содержит. Список переменных окружения кончается в тот момент, когда при его переборе встречается указатель NULL. Пример такого перебора представлен ниже:
</p>
<pre>
#include "stdlib.h"
#include "stdio.h"
void main(argc,argv,env)
int argc;
char *argv[];
char *env[];
{
int i;
i=0;
while(env[i])
{
printf("%d:%s\n",i,env[i]);
i++;
}

}
</pre>
<p>
В данном случае перебор идет до тех пор, пока значение указателя больше 0. При этом переменные окружения выдаются в виде "имя:значение". Для того, чтобы воспользоваться этими значениями, придется разбирать каждую строку, выделяя имя и значение переменной при помощи манипуляций с адресами внутри строки. Любые адресные операции — это потенциальные ошибки (хотя они и позволяют писать быстрые программы).
</p>
<p>
К счастью, в С есть функция getenv(). В качестве аргумента этой функции достаточно указать имя переменной окружения, и система вернет указатель на его значение. Например, необходимо знать, сколько символов нужно считать со стандартного ввода скрипта:
</p>
<pre>
int i,n;
char *query;
...
n = atoi(getenv("CONTENT_LENGTH"));
query = (char *) malloc(n+1);
for(i=0;i< n;i++)
{
query[i] = getc();
}
...
free(query);
</pre>
<p>
В этом примере при помощи последовательного применения getenv и atoi (ascii to integer) из переменной окружения в переменную целого типа помещается значение переменной окружения — CONTENT_LENGTH. Последовательное применение функций здесь необходимо, т.к. значение переменной окружения — строка, а мы хотим использовать число, следовательно, строку символов следует не только получить, но еще и преобразовать в число.
</p>
<p>
Для преобразования строк в числа часто используют функцию форматного ввода sscanf. В нашем случае это выглядело примерно следующим образом:
</p>
<pre>
char *length;
int n;
...
length = getenv("CONTENT_LENGTH");
sscanf(length,"%d",&n);
...
</pre>
<p>
Следует заметить, что sscanf — это довольно сложная функция. Она предназначена для ввода любой информации и ее преобразования. Как показывает практика, иногда sscanf работает не так, как предполагает программист. Поэтому незачем стрелять из пушки по воробьям — применяйте лучше специализированные функции преобразования, например, atoi, если это возможно.
</p>
	</div>
</body>
</html>