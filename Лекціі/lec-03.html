<!DOCTYPE html>
<html>
<head>
	<title>Інструментальні засоби візуального програмування. Лекція №3 </title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
	<div class="paper">
		<div id="colontitle">Інструментальні засоби візуального програмування. Лекція №3 </div>
		<h1>Робота з масивами у мові РНР. Цикли</h1>

		<h2>Оператори циклу</h2>

		<p>
		<strong>Оператор циклу</strong> з передумовою
		</p>
<pre>
while(умова)
  блок операторів
</pre>

<p>
<strong>Приклад. </strong>Підрахувати суму перших п'яти членів натурального ряду
</p>

<pre>
$S = 0; $i = 0;
while($i $S&lt; 5)
{ $i++;
  $S += $i;
}
print "S=$S&lt;BR>"; //S=15
</pre>

<p>
<strong>Оператор циклу</strong> з післяумовою
</p>
<pre>
do
  блок операторів
while(умова);
</pre>

<p><strong>Приклад. </strong>Підрахувати суму перших п'яти членів натурального ряду
</p>
<pre>
$S = 0; $i = 0;
do
{ $i++;
  $S += $i;
}
while($i &lt; 5);
print "S=$S &lt;BR>"; //S=15
</pre>

<p>У наступному прикладі двома способами обчислюється квадратний корінь з двох
за допомогою алгоритму Герона. Видно різницю між операторами while і do ... while.
</p>

<pre>
$x=2;$y=1.5;
<B>$z = $x/$y;</b>
while (abs($z -$y) > 0.001) 
{    $y =($z + $y)/2;
     $z = $x/$y;
}
print "y=$y&lt;BR>"; //y=1.41421568627

$x=2;$y=1.5;
do
{    $z = $x/$y;
     $y =($z + $y)/2;    
}
while (abs($z -$y) > 0.001);
print "y=$y&lt;BR>"; //y=1.41421568627
</pre>
<p><strong>Оператор циклу</strong> із заданою кількістю повторень
</p>

<pre>
for(початкове_значення; умова_виходу; крок
</pre>

<p>
<strong>Приклад.</strong> Підрахувати суму перших п'яти членів натурального ряду
</p>
<pre>
$S=0;
for($i = 1; $i &lt; 6; $i++)$S += $i;
print "S=$S&ltBR>"; //S=15
</pre>

<h2>Управління циклом</h2>
<p>Рідко, але доводиться порушувати хід виконання циклу, наприклад, при певних умовах вийти з оператора циклу.        Виникає необхідність в додаткових, крім наданих операторами циклу. засобах управління циклом. Для цього в PHP служать оператори break і continue.
</p>
<p>
<strong>Оператор break </strong>служить для переходу на перший оператор після циклу
</p>

<p>
<strong>Приклад.</strong> Як тільки елемент масиву $ A стане рівним нулю, вийти з циклу.
</p>

<pre>
$K = 0;
$A = Array(2,7,12, 1,11,1, 3,2,4, 9);
for($i=0; $i &lt; 10; $i++)
{ $A[$i]--;
  if(!$A[$i]) break;
  $K++;
}
print "K = $K&lt;BR>";//$K=3
</pre>

<p>
<strong>Оператор continue</strong> служить для переходу на наступну ітерацію циклу.
</p>
<p>
<strong>Приклад.</strong> Всі елементи масиву зменшуються на одиницю і підраховується кількість ненульових елементів в оновленому масиві.
</p>

<pre>
$K = 0;
$A = Array(2,7,12, 1,7,5, 1,2,1, 9);
for($i=0; $i &lt;10; $i++)
{ $A[$i]--;
  if(!$A[$i]) continue;
  $K++;
}
print "K = $K&lt;BR>";//$K=7
</pre>

<p>
<strong>Оператор foreach</strong> буде розглянуто разом з масивами в наступній лекції.
</p>

<h2>Масиви</h2>
<h3>Особливості масивів в PHP</h3>
<p>
Своєрідність PHP в тому, що в ньому масиви мають такі властивості.
</p>

<ol>
	<li>Всі масиви - асоціативні.</li> 
	<li>Якщо ключі - цілі числа, то масивом можна користуватися як масивом з числовими індексами.</li> 
	<li>Елементи в масиві можуть мати різні типи.</li>
	<li>Кількість елементів в різних рядках двовимірного масиву може бути різним.</li>
</ol>

<h2>Створення масиву c числовими індексами</h2>
<p>
Створимо масив з одного елемента
</p>

<pre>
$m0=array('весна');
print "m0[0]=$m0[0]&lt;BR>"; // m0[0]=весна
//Можна створити масив, присвоївши значення його елементу
$m1[0] = 3; //$m1 - новий масив
print "m1[0]=$m1[0]&lt;BR>"; //m1[0]=3
</pre>

<p>
Створимо масив з трьох елементів.
</p>
<pre>
$M1 = array(2,7,12);
</pre>
<p>
Додамо до нього ще 2 елементи
</p>
<pre>
$M1[3] = 'Маша';
$M1[4] = 2.71;
</pre>

<p>Додамо до нього відразу 7-й елемент, пропустивши 5-й і 6-й, і роздрукуємо весь масив, вважаючи, що в ньому не 8, а 9 елементів:
</p>
<pre>
$M1[7] = 100;
for($i=0; $i&lt;=8; $i++)print "\$M1[$i] = $M1[$i]&lt;BR>";
/*надрукується
$M1[0] = 2
$M1[1] = 7
$M1[2] = 12
$M1[3] = Маша
$M1[4] = 2.71
$M1[5] = 
$M1[6] =
$M1[7] = 100
$M1[8] =
У масиві 9 елементів, але 3 з них порожні.
*/
</pre>

<h2>Асоціативні масиви та оператор <strong>foreach</strong></h2>

<p>
Створимо очевидний асоціативний масив і роздрукуємо його.
</p>
<pre>
$AssM['сезон'] = 'весна';
$AssM['місяць'] = 'травень';
$AssM['число'] = 1;
foreach($AssM as $kluch => $znach) print "$kluch - $znach&lt;BR>;
/* Надрукується
  сезон - весна
  місяць - травень
  число - 1
*/
</pre>

<p>Часто потрібно перебрати всі елементи масив, довжина якого невідома, наприклад, при читанні в масив текстового файлу. Для цієї мети служить оператор<strong>foreach</strong>.
Існують два різновиди foreach. Наведений вище оператор служить для перебору масиву,
розглянутого, як асоціативний. Роздрукуємо масив $AssM, як масив з числовими
індексами, використовуючи інший різновид foreach.
</p>
<pre>
foreach($AssM as $znach) print "$znach&lt;BR>";
/* Надрукується
  весна
  травень
  1
*/
</pre>

<p>Більш наочний наступний спосіб створення асоціативного масиву:
</p>

<pre>
$cveta=array(
  "red"=>"Червоний",
  "yellow"=>"Жовтий",
  "green"=>"Зелений",
  "blue"=>"Синій",
  "maroon"=>"Каштановий"
);   
</pre>

<p>
Роздрукуємо як асоціативний масив $ M1, який створювався як масив з числовими індексами.
</p>
<pre>
foreach($M1 as $kluch => $znach) print "$kluch - $znach&lt;BR>;
/* Надрукується
0 - 2
1 - 7
2 - 12
3 - Маша
4 - 2.71
7 - 100
*/
</pre>

<h2>Операції з масивами</h2>
<ul>
	<li> +    - об'єднання по ключам;</li>
	<li> ==   - true, якщо $a і $b містять однакові елементи;</li>
	<li> ===  - true, якщо $a і $b містять однакові елементи, розташовані в однаковому порядку;</li>
	<li> !=   - true, якщо в $a і $b є неоднакові елементи;</li>
	<li> &lt;&gt;   - то ж, що і!=</li>
	<li> !==  - true, якщо $a і $b містять однакові елементи, але порядок елементів різний;</li>
</ul>
<p>
<strong>Приклади</strong>
</p>
<p>
<strong>Об'єднання по ключам</strong>. 
</p>
<pre>
$a = array(1,2);
$b = array(3,4);
//У цих масивів ключі мають однакові значення 0 і 1
$c = $a + $b;
foreach($c as $x)print "$x ";
// Результат 1 2
// Елементи з повторюваними ключами беруться тільки один раз
//
$d = array(2 => 'a', 3 => 'b', 8 => 'c')
// Ключі в $a - 0, 1; ключі в $d - 2, 3, 8. Співпадаючих ключів немає
$c = $a + $d; //$c=(1,2,'a','b','c')
</pre>

<p>
<strong>Порівняння масивів</strong>
</p>
<pre>
$b = $a; //Копіювання масиву. $b і $a однакові масиви
$g = $a == $b; //$g = 1, т.е. "істина"
$g = $a === $b; //$g = 1, т.е. "істина"
$c = array(0 => 2, 1 => 1);
$g = $a ==  $c; //$g = 1, т.е. "істина"
$g = $a ===  $c; //$g = 0, т.е. "брехня", не ідентичне
</pre>

<h2>Функції, для роботи з масивами</h2>
<p>У PHP величезна кількість вбудованих функцій. У керівництві по PHP, випущеному в 2005 році, описується 5211 функцій. Тільки на перегляд такої кількості потрібно 5211/4/8 = 163 робочих дня, якщо на кожну функцію витрачати по 15 хвилин. І це різноманіття весь час поповнюється. Функцій для роботи з масивами - 80. Розглянемо лише деякі з них.
</p>
<p>
<strong>count(ім'я_масиву)</strong> - функція, яка повертає кількість елементів в масиві. Підрахуємо довжину розглянутого вище масиву $M1:
</p>

<pre>
$L = count($M1); //$L=6
</pre>
<p>
З прикладу випливає, що функція count повертає кількість непустих елементів масиву.
</p>

<p><strong>Функції сортування</strong>
<ul>
	<li>sort(ім'я_масиву) - сортування за зростанням елементів масиву з числовими індексами.</li>
	<li>asort(ім'я_масиву) - сортування асоціативного масиву по зростанню значень.</li>
	<li>ksort(ім'я_масиву) - сортування асоціативного масиву по зростанню ключів.</li>
	<li>rsort(ім'я_масиву) - сортування за спаданням елементів масиву з числовими індексами.</li>	
	<li>arsort(ім'я_масиву) - сортування асоціативного масиву по спадаючій значень.</li>
	<li>krsort(ім'я_масиву) - сортування асоціативного масиву по спадаючій ключів.</li>
	<li>usort(ім'я_масиву) - обумовлена користувачем функція сортування масиву з числовими індексами.</li>	
	<li>uasort(ім'я_масиву) - обумовлена користувачем функція сортування асоціативного масиву за значеннями.</li>
	<li>uksort(ім'я_масиву) - обумовлена користувачем функція сортування асоціативного масиву по ключах.</li>
</ul>

<p>
<strong>Приклади</strong>
</p>
<p>
Сортування по зростанню елементів масиву з числовими індексами.
</p>

<pre>
sort($M1);
for($i=0; $i&lt;9; $i++)print "\$M1[$i] = $M1[$i]&ltBR>";
/*Результат сортування
  $M1[0] = Маша
  $M1[1] = 2
  $M1[2] = 2.71
  $M1[3] = 7
  $M1[4] = 12
  $M1[5] = 100
  $M1[6] =
  $M1[7] =
  $M1[8] = 
*/
</pre>

<p>
Сортування асоціативного масиву $cveta по зростанню значень
</p>
<pre>
asort($cveta);
foreach($cveta as $kluch=>$znach)
  print "$kluch - $znach&ltBR>";
/*Результат сортування 
  yellow - Жовтий
  green -  Зелений
  maroon - Каштановый
  red -    Червоний
  blue -   Синій
*/
</pre>

<P>
Сортування асоціативного масиву $cveta по зростанню ключів
</p>
<pre>
ksort($cveta);
foreach($cveta as $kluch=>$znach)
  print "$kluch - $znach&ltBR>";
/*Результат сортировки   
  blue -   Синій
  green -  Зелений
  maroon - Каштановый
  red -    Червоний
  yellow - Жовтий
*/
</pre>

<p>
<strong>Функції для додавання і видалення елементів масиву</strong>
</p>
<ul>
	<li>array_pad - збільшити розмір масиву до заданої величини.</li>
	<li>array_pop - витягти останній елемент масиву.</li>
	<li>array_push -  додати один або кілька елементів в кінець масиву.</li>
	<li>array_shift -  витягти перший елемент масиву.</li>
	<li>array_unshift - додати один або кілька елементів в початок масиву.</li> 
</ul>

<p>Часто застосовується функція <strong>array_shift(array)</strong>, яка витягує значення першого елемента масиву <strong>array</strong> і повертає це значення, скорочуючи розмір <strong>array</strong>  на один елемент. Всі числові ключі будуть змінені таким чином, що нумерація масиву почнеться з нуля, в той час як рядкові ключі залишаться колишніми. Якщо array порожній (або не є масивом), буде повернуто <strong>NULL</strong>.
</p>

<p>
Цю функцію зручно використовувати для видалення з масиву і запам'ятовування в окремій змінній шапки таблиці.
</p>
<p>
<strong>Приклад</strong>
</p>
<pre>
$Arr = Array('a'=> 'alfa','b'=> 'beta','c'=> 'gamma');
$a1 = array_shift($Arr);
print_r ($Arr); //print_r - функція для налагоджування друку
print "\$a1=$a1&lt;BR>";
//Результат
// Array ( [b] => beta [c] => gamma ) 
//  $a1=alfa  
</pre>

<h2>Двовимірні масиви</h2>
<P>
Створимо двовимірний масив
</p>
<pre>
$M2= array(
  array(1,2,3),
  array(4,5,6,'сім'),
  array('a','b','c'),
);
</pre>

<p>
Можна створювати двовимірний масив поелементно.
</p>

<pre>
$M3[0][0]='alfa';
$M3[0][1]='beta';
</pre>

<P>
Підрахуємо кількість рядків в масиві $M2 і кількість елементів в рядку M2[1].
</p>

<pre>
$Lrow = count($M2); // $Lrow = 3
$Lcol = count($M2[1]); // $Lcol = 4
</pre>

<p>
Роздрукуємо двовимірний масив $M2.
</p>

<pre>
foreach($M2 as $row)
{  foreach ($row as $el)
  { print "$el ";
  }
  print '&lt;BR>';
}
/* Результат
  1 2 3
  4 5 6 семь
  a b c 
*/
</pre>

<p>
Створимо явний асоціативний масив, додавши в $М3 рядок
</p>

<pre>
$M3['odin'][0] = 'два';
$M3['odin'][1] = 'три';
print 'L='.count($M3)." \$M3['odin'][1] = ".$M3['odin'][1]."&lt;BR>";
/* Результат
  L=2 $M3['odin'][1] = три
*/
</pre>

<p>
<strong>Приклад сортування двовимірного масиву за допомогою функції usort().</strong>
</p>
<p>
Сортується масив $M2 по другій колонці (з індексом 1) в порядку зростання
</p>

<pre>
usort($M2, 'compare1');
foreach($M2 as $row)
{  foreach ($row as $el)
  { print "$el ";
  }
  print '&lt;BR>';
}
/* Результат
  a b c
  1 2 3
  4 5 6 сім
*/
function compare1($x,$y) //Сортування по зростанню
{                        //$x и $y - два сусідніх рядки
  if($x[1] == $y[1]) return 0; //порядок не визначено
  elseif(($x[1] > $y[1]) return 0; //першим $y[1]
  else                   return 1; //першим $x[1]
}
</pre>

<h2>Масив асоціативний або з числовими індексами?</h2>
<p>Якщо де-небудь що-небудь убуде,
то десь щось додасться.
Закон збереження.
</p>

<p>У PHP всі масиви асоціативні, тобто, форально в PHP немає, на відміну від більшості мов високого рівня, масивів з числовими індексами. Згідно наведеним в жартівливій фомі в епіграфі цього пункту закону збереження, таке рішення повинно привести і до позитивних і до негативних наслідків.
</p>	
<p>
<strong>Переваги асоціативних масивів. </strong> Застосування асоціативних масивів замість масивів з числовими індексами в деяких випадках дозволяє сильно спростити програму, наприклад програму обробки повідомлень у вузлі зв'язку. Слід зазначити, що такі випадки на практиці зустрічаються нечасто.
</p>
<p>
<strong>Недоліки асоціативних масивів</strong> в порівнянні з масивами з числовими індексами:
</p>

<ul>
	<li>займають більше місця в пам'яті;</li>
	<li>більший час вибірки елемента;</li>
	<li>дуже складні, приховані від прикладної програми, алгоритми запису і вибірки.</li>
</ul>

<p>Розглянемо приклад, в якому будемо використовувати масив <strong> $ MC </strong> як масив з числовими індексами. Створимо два перших елемента:
</p>

<pre>
$MC[0] = 'синій';
$MC[1] = 'зелений';
</pre>

<p>Підрахуємо кількість елементів в масиві та роздрукуємо його за допомогою оператора <strong>for</strong>, який використовується тільки в разі, коли масив розглядається як масив з числовими індексами.
</p>
<pre>
$L=count($MC);
for ($i=0; $i &lt; $L; $i++) print "$i $MC[$i]&lt;BR>";
/* Результат
0  синій
1  зелений
*/
</pre>

<P>Припустимо, що програма, в якій використовується масив <strong>$MC</strong>, велика, розробляється довго і програміст в якийсь момент забув, що використовує <strong>$MC</strong> як масив з числовими індексами, і додав новий елемент з текстовим ключем:
</p>

<pre>
$MC['red'] = 'Червоний';
</pre>

<p>
Знову підрахуємо кількість елементів і роздрукуємо масив <strong>$MC</strong>
</p>
<pre>
$L=count($MC);
for ($i=0; $i < $L; $i++) print "$i $MC[$i]&lt;BR>";
/* Результат
0  синій
1  зелений
2
*/
</pre>

<p>
Так як ми домовилися, що в даній програмі <strong>$MC</strong> використовується тільки як масив з числовими індексами, то елемент <strong>$MC['red']</strong> зі значенням 'Червоний' ніколи не буде використовуватися. Його, як би, немає. Така помилка дуже важко виявляється, але виникла вона внаслідок спрощення мови. В одному місці поменшало, в іншому додалося, причому дуже неприємно додалося.
</p>

<p>
<strong>Порожні та напівпорожні елементи масиву</strong>
</p>
<p>Елементи використовуваних в більшості мов програмування справжніх масивів з числовими індексами розташовуються в послідовних комірках пам'яті. Якщо масив, що складається з <strong>m</strong> елементів, розташований, починаючи з комірки з адресою <strong>n</strong>, то адреса <strong>i-го</strong> елемента дорівнює <strong>n + i</strong>. Таким чином, для того щоб знайти <strong>i-й</strong> елемент масиву, потрібно зберігати тільки адресу початку та довжину масиву з числовими індексами. Індекси елементів такого масиву, на відміну від ключів асоціативного масиву, зберігати в пам'яті ЕОМ не потрібно.
</p>
<p>
Будь-яка комірка пам'яті в будь-який момент часу містить якийсь набір нулів і одиниць, тобто, фізично порожніх комірок бути не може. Семантично (логічно) елементи масиву можуть бути порожніми, наприклад  в <strong>i-й</strong> елемент масиву цін не занесена ціна товару. Для вказівки, що елемент масиву порожній, служить спеціальна величина <strong>NULL</strong>, збережена в цьому елементі.
</p>

<p>
Розглянемо, що розуміється під "порожнім" елементом масиву в PHP. Створимо масив $M:
</p>
<pre>
$M[0]=100;
$M[1]=200;
$M['red']='червоний';
$M[3]=NULL;
$M[4]=FAlSE;
$M[5]='';
$M[8]=300;
</pre>

<p>
Роздрукуємо цей масив трьома способами.
</p>
<p>
1. Як масив з числовими індексами.
</p>

<pre>
for ($i=0; $i < 9; $i++) print "$i $M[$i]&lt;BR>";

Результат
0 100
1 200
2
3
4
5
6
7
8 300
</pre>

<p>
Елемент з ключем 'red' непомітний, елементи зі значеннями <strong>NULL, FALSE, '' (дві лапки)</strong> та елементи <strong>$M[2], $M[6], $M[7]</strong> - порожні.
</p>

<p>
2. За допомогою оператора <strong>foreach</strong> роздрукуємо тільки значення елементів.
</p>

<pre>
$i=0;
foreach(($M) as $x ) print $i++." $x&lt;BR>";

Результат
0 100
1 200
2 червоний
3
4
5
6 300
</pre>

<p>
3. За допомогою оператора <strong>foreach</strong> роздрукуємо всі елементи масиву і ключі.
</p>

<pre>
foreach(($M) as $k => $z ) print "$k $z&lt;BR>";

Результат
<strong>Ключ значення</strong>
0       100
1       200
red     червоний
3
4
5
8       300
</pre>

<p>
З порівняння дійсного вмісту масиву <strong>$M</strong> з результатами виведення на друк означає, що елементи з індексами 2, 6, 7 не існують, а елементи 3, 4, 5 мають ключі, але не мають значень.
</p>

<p>У цьому короткому огляді перераховані далеко не всі проблеми, що виникають через відсутність в<strong>PHP</strong> явного типа массивов с числовыми индексами.
				
		</div>
	</body>
	</html>