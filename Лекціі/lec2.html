
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML+RDFa 1.0//EN"
  "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" version="XHTML+RDFa 1.0" dir="ltr">
  
<head profile="http://www.w3.org/1999/xhtml/vocab">
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="shortcut icon" href="http://www.e-helper.com.ua/sites/default/files/fav.ico" type="image/vnd.microsoft.icon" />
<meta name="HandheldFriendly" content="true" />
<link rel="shortlink" href="/node/107" />
<meta name="Generator" content="Drupal 7 (http://drupal.org)" />
<link rel="canonical" href="/node/107" />
<meta name="MobileOptimized" content="width" />
  <title>Лекція №1 | e-helper.com.ua</title>
  

<style type="text/css" media="all">
@import url("http://www.e-helper.com.ua/sites/all/themes/skeletontheme/css/skeleton.css?p9st73");
@import url("http://www.e-helper.com.ua/sites/all/themes/skeletontheme/css/style.css?p9st73");
@import url("http://www.e-helper.com.ua/sites/all/themes/skeletontheme/css/buttons.css?p9st73");
@import url("http://www.e-helper.com.ua/sites/all/themes/skeletontheme/css/layout.css?p9st73");
@import url("http://www.e-helper.com.ua/sites/all/themes/skeletontheme/color/colors.css?p9st73");
</style>
  


</head>
<body class="html not-front not-logged-in one-sidebar sidebar-first page-node page-node- page-node-107 node-type-article" >
                 
                <div id="node-107" class="node node-article node-promoted clearfix" about="/node/107" typeof="sioc:Item foaf:Document">

      <span property="dc:title" content="Лекція №1" class="rdf-meta element-hidden"></span>
  
  <div class="content clearfix">
    <div class="field field-name-body field-type-text-with-summary field-label-hidden"><div class="field-items"><div class="field-item even" property="content:encoded"><p> </p>
<h1 align="center"> Лекція №2</h1>
<h1>Що таке PHP, Можливості PHP, Коментарі, Змінні, константи й оператори, Масиви та списки в PHP, Керуючі конструкції, Цикли, Оператори передачі управління, Оператори включення, Функції користувача, Символічні і жорсткі посилання</h1>
<h1 align="center">Що таке PHP</h1>
<p><strong>PHP</strong>- це широко розповсюджена мова сценаріїв загального призначення з відкритим вихідним кодом.</p>
<p>Говорячи простіше, PHP це мова програмування, спеціально розроблена для написання web-додатків, що виконуються на Web-сервері.</p>
<p>Абревіатура PHP означає <strong>"Hypertext Preprocessor (Препроцесор Гіпертексту)"</strong>. Синтаксис мови бере початок з C, Java і Perl. PHP досить простий для вивчення. Перевагою PHP є надання web-розробникам можливості швидкого створення динамічних web-сторінок.</p>
<p>Важливою <strong>перевагою</strong> мови PHP перед такими мовами, як мов Perl і C полягає в можливості створення HTML документів із вбудованими командами PHP.</p>
<p>Значною відмінністю PHP від якого-небудь коду, що виконується на стороні клієнта, наприклад, JavaScript, є те, що PHP-скрипти виконуються на стороні сервера. Ви навіть можете конфігурувати свій сервер таким чином, щоб HTML-файли оброблялися процесором PHP, так що клієнти навіть не зможуть дізнатися, чи отримують вони звичайний HTML-файл або результат виконання скрипта.</p>
<p>PHP дозволяє створювати якісні Web-додатки за дуже короткі терміни, отримані продукти легко модифікуються і підтримуються в майбутньому.</p>
<p>PHP простий для освоєння, і разом з тим здатний задовольнити інтереси професійних програмістів.</p>
<p>Мова PHP постійно удосконалюється, і їй, напевно забезпечене довге домінування в області мов web-програмування, принаймні, найближчим часом.</p>
<p align="center"><strong>Можливості PHP</strong></p>
<p>PHP може все. <strong>Головна область застосування </strong>PHP - це написання скриптів, що працюють на стороні сервера; таким чином, PHP здатний виконувати все те, що виконує будь-яка інша програма CGI, наприклад, обробляти дані форм, генерувати динамічні сторінки або відсилати й приймати cookies. Але PHP здатний виконувати ще і багато інших завдань.</p>
<p align="center"><strong>Існують три основні області застосування PHP.</strong></p>
<ul><li><em>Створення скриптів для виконання на стороні сервера.</em> PHP найбільш широко використовується саме таким чином. Все, що вам знадобиться, це інтерпретатор PHP (у вигляді програми CGI або серверного модуля), вебсервер і браузер. Для того щоб можна було переглядати результати виконання PHP-скриптів в браузері, потрібен працюючий веб-сервер і встановлений PHP. У випадку, якщо ви просто експериментуєте, ви цілком можете використовувати свій домашній комп'ютер замість сервера.</li>
</ul><ul><li><em>Створення скриптів для виконання в командному рядку.</em> Ви можете створити PHP-скрипт, здатний запускатися незалежно від веб-сервера та броузера. Все, що вам буде потрібно – <strong>парсер</strong> PHP. Такий спосіб використання PHP ідеально підходить для скриптів, які повинні виконуватися регулярно, наприклад, за допомогою cron (на платформах * nix або Linux) або за допомогою планувальника завдань (Task Scheduler) на платформах Windows. Ці скрипти також можуть бути використані в задачах простої обробки текстів.</li>
</ul><ul><li><em>Створення звичайних програм, що виконуються на стороні клієнта.</em> Можливо, PHP є не найкращою мовою для створення подібних додатків, але, якщо ви дуже добре знаєте PHP і хотіли б використати деякі його можливості у своїх клієнт-додатках, ви можете використовувати PHP-GTK для створення таких додатків. Подібним чином ви можете створювати і крос-платформні додатки. PHP-GTK є розширенням PHP і не поставляється разом з дистрибутивом PHP.</li>
</ul><p>PHP доступний для більшості операційних систем, включаючи <strong>Linux</strong>, багато модифікації <strong>Unix</strong> (такі, як HP-UX, Solaris і OpenBSD), Microsoft Windows, Mac OS X, RISC OS, та багатьох інших. Також в PHP включена підтримка більшості сучасних веб-серверів, таких, як Apache, Microsoft Internet Information Server, Personal Web Server, серверів Netscape і iPlanet, сервера Oreilly Website Pro, Caudium, Xitami, OmniHTTPd та багатьох інших. Для більшості серверів PHP поставляється в якості модуля, для інших, що підтримують стандарт CGI, PHP може функціонувати як процесор CGI.</p>
<p>Таким чином, вибираючи PHP, ви отримуєте свободу вибору операційної системи і веб-сервера. Крім того, у вас з'являється вибір між використанням процедурного або об'єктно-орієнтованого програмування або ж їх поєднання. Багато бібліотек коду і великі програми (включаючи бібліотеку PEAR) написані тільки з використанням ООП.</p>
<p>PHP здатний генерувати не тільки HTML. Доступно формування зображень, файлів PDF і навіть роликів Flash (з використанням libswf і Ming), що створюються «на льоту». PHP також здатний генерувати будь-які текстові дані, такі, як XHTML та інші XML-файли. PHP може здійснювати автоматичну генерацію таких файлів і зберігати їх у файловій системі вашого сервера замість того, щоб віддавати клієнту, організовуючи, таким чином, кеш динамічного наповнення, розташований на стороні сервера.</p>
<h1 align="center">Інструментарій</h1>
<h2 align="center">Мінімальна програма</h2>
<p>Традиційно, знайомство з мовою програмування починають з горезвісної програми "Hello, World!". Що ж, ми не будемо відступати від цієї традиції, і напишемо нашу першу програму на PHP!</p>
<p>Отже, беремо редактор PHP-коду, і напишемо наступний PHP код:</p>
<p style="margin-left:14.2pt;">&lt;? Php<br />echo "Hello, World!";<br />?&gt;</p>
<p>Перш, ніж запустити програму, її потрібно встановити на сервері. Для цього збережіть написаний PHP-скрипт під назвою <strong>start.php</strong>. Потім скопіюйте його в каталог <strong>DocumentRoot</strong> вашого сервера. Тепер наберіть в адресному рядку вашого браузера <strong><a href="http://localhost/start.php">http://localhost/start.php</a></strong> і, якщо все встановлено і налаштовано правильно, ви побачите текст Hello, World!</p>
<p> </p>
<h1 align="center">Синтаксис</h1>
<p>Ми приступаємо до вивчення основних елементів синтаксису мови PHP. Розглянемо способи поділу інструкцій і створення коментарів, змінні, константи, типи даних і оператори.</p>
<h1 align="center">Основний синтаксис</h1>
<p>Перше, що потрібно знати щодо синтаксису PHP, - це те, як він вбудовується в HTML-код, як інтерпретатор дізнається, що це код на мові PHP. В прикладах ми найчастіше будемо використовувати варіант &lt;? Php?&gt;, І іноді скорочений варіант &lt;? ?&gt;.</p>
<h1 align="center">Поділ інструкцій</h1>
<p>Програма на <strong>PHP</strong> (та й на будь-якій іншій мові програмування) - це набір команд (інструкцій). Оброблювачу програми (парсеру) необхідно якось відрізняти одну команду від іншої. Для цього використовуються спеціальні символи - роздільники. У PHP інструкції поділяються так само, як і у Cі або Perl, - кожен вираз закінчується крапкою з комою.</p>
<p>Закриваючий тег «?&gt;» Має на увазі кінець інструкції, тому перед ним крапку з комою не ставлять. Наприклад, два наступних фрагмента коду еквівалентні:</p>
<p style="margin-left:14.2pt;">&lt;? Php  <br />echo "Hello, world!"; / / крапка з комою      <br />// В кінці команди   <br />// Обов'язкова<br />?&gt; <br />&lt;? Php   <br />echo "Hello, world!" ?&gt;     <br />&lt;! - Крапка з комою<br />опускається з-за "?&gt;" -&gt;</p>
<h1 align="center">Коментарі</h1>
<p>Часто при написанні програм виникає необхідність робити будь-які коментарі до коду, які ніяк не впливають на сам код, а тільки пояснюють його. Це важливо при створенні великих програм і у випадку, якщо кілька людей працюють над однією програмою. При наявності коментарів у програмі в її коді розібратися набагато простіше. Крім того, якщо вирішувати задачу по частинах, недороблені частини рішення також зручно коментувати, щоб не забути про них надалі. В усіх мовах програмування передбачена можливість включати коментарі в код програми. PHP підтримує кілька видів коментарів: у стилі Сі, C ++ і оболонки Unix. Символи // і # позначають початок однорядкових коментарів, /* і */ - відповідно початок і кінець багаторядкових коментарів.</p>
<p style="margin-left:14.2pt;"><strong>Приклад 1.</strong> Використання коментарів в PHP </p>
<p style="margin-left:14.2pt;">&lt;? Php<br />echo "Мене звуть Вася";<br />// Це однорядковий коментар<br />// У стилі С ++<br />echo "Прізвище моє Петров";<br />/* Це багаторядковий коментар.<br />Тут можна написати кілька рядків.<br />При виконанні програми все, що<br />знаходиться тут, буде проігнороване. */<br />echo "Я вивчаю PHP";<br /># Це коментар в стилі<br /># Оболонки Unix<br />?&gt;</p>
<h1 align="center"> </h1>
<h1 align="center">Змінні, константи й оператори</h1>
<p>Важливим елементом кожної мови є змінні, константи й оператори. Розглянемо, як виділяються і обробляються ці елементи в PHP.</p>
<h1 align="center">Змінні</h1>
<p>Змінна у PHP позначається знаком долара, за яким слідує її ім'я. Наприклад: $My_var</p>
<p>Ім'я змінної чутливо до регістру, тобто змінні <strong>$my_var</strong> і <strong>$My_var різні</strong>.</p>
<p>Імена змінних відповідають тим же правилам, що й інші найменування в PHP: правильне ім'я змінної має починатися з букви або символу підкреслення з подальшим в будь-якій кількості літерами, цифрами або символами підкреслення.</p>
<p>У PHP змінні завжди присвоювалися за значенням. Тобто коли ви присвоюєте вираз змінної, всі значення оригінального виразу копіюються в цю змінну. Це означає, наприклад, що після присвоєння однієї змінної значення іншої, зміна однієї з них не впливає на значення іншої.</p>
<p> </p>
<h1 align="center">Константи</h1>
<p>Для зберігання постійних величин, тобто таких величин, значення яких не змінюється в ході виконання скрипта, використовуються константи. Такими величинами можуть бути математичні константи, паролі, шляхи до файлів і т.п. Основна відмінність константи від змінної полягає в тому, що їй не можна присвоїти значення більше одного разу і її значення не можна анулювати після її оголошення. Крім того, у константи немає приставки у вигляді знаку долара і її не можна визначити простим присвоєнням значення. Як же тоді можна визначити константу? Для цього існує спеціальна функція define (). Її синтаксис такий:</p>
<p align="center">define ("Імя_константи", <br />"Значення_константи", <br />[Нечутливість _до_регістру])</p>
<p>За замовчуванням імена констант чутливі до регістру. Для кожної константи це можна змінити, вказавши в якості значення аргументу Нечутливість _до_регістру значення True. Існує правило, за яким імена констант завжди пишуться у верхньому регістрі.</p>
<p>Отримати значення константи можна, вказавши її ім'я. На відміну від змінних, не потрібно випереджати ім'я константи символом $. Крім того, для отримання значення константи можна використовувати функцію constant () з ім'ям константи в якості параметра.</p>
<p><strong>Приклад 3.</strong> Константи в PHP</p>
<p style="margin-left:14.2pt;">&lt;? Php  <br />// Визначаємо константу  <br />// PASSWORD         <br />define ("PASSWORD", "qwerty");       <br />// Визначаємо регістро незалежну     <br />// Константу PI зі значенням 3.14       <br />define ("PI", "3.14", True);<br />// Виведемо значення константи PASSWORD,    <br />// Тобто qwerty        <br />echo (PASSWORD);<br />// Теж виведе qwerty<br />echo constant ("PASSWORD"); <br />echo (password);      <br />/ * Виведе password і попередження, <br />оскільки ми ввели регістрочутливу   <br />константу PASSWORD * /        <br />echo pi;  <br />// Виведе 3.14, оскільки константа PI <br />// Регістронезалежна за визначенням <br />?&gt; <br /> </p>
<p>Крім змінних, які декларуються користувачем, про які ми тільки що розповіли, в PHP існує ряд констант, що визначаються самим інтерпретатором. Наприклад, константа <strong>__FILE__</strong> зберігає ім'я файлу програми (і шлях до нього), яка виконується в даний момент, <strong>__FUNCTION__</strong> містить ім'я функції, <strong>__CLASS__</strong> - ім'я класу, <strong>PHP_VERSION</strong> - версія інтерпретатора PHP. Повний список зумовлених констант можна отримати, прочитавши посібник з PHP.</p>
<p> </p>
<h1 align="center">Оператори</h1>
<p>Оператори дозволяють виконувати різні дії зі змінними, константами і виразами. Вираз можна визначити як все, що завгодно, що має значення. Змінні і константи - це основні і найбільш прості форми виразів. Існує безліч операцій (і відповідних їм операторів), які можна робити з виразами. Розглянемо деякі з них докладніше.</p>
<p><strong>Таблиця 1.</strong> Арифметичні оператори</p>
<table border="1" cellpadding="0" cellspacing="0" style="width:100.0%;" width="100%"><tbody><tr><td style="width:29.46%;">
<p align="center">Позначення</p>
</td>
<td style="width:48.02%;">
<p align="center">Назва</p>
</td>
<td style="width:22.52%;">
<p align="center">Приклад</p>
</td>
</tr><tr><td style="width:29.46%;">
<p>+</p>
</td>
<td style="width:48.02%;">
<p>Додавання</p>
</td>
<td style="width:22.52%;">
<p>$a + $b</p>
</td>
</tr><tr><td style="width:29.46%;">
<p>-</p>
</td>
<td style="width:48.02%;">
<p>Віднімання</p>
</td>
<td style="width:22.52%;">
<p>$a - $b</p>
</td>
</tr><tr><td style="width:29.46%;">
<p>*</p>
</td>
<td style="width:48.02%;">
<p>Множення</p>
</td>
<td style="width:22.52%;">
<p>$a * $b</p>
</td>
</tr><tr><td style="width:29.46%;">
<p>/</p>
</td>
<td style="width:48.02%;">
<p>Ділення</p>
</td>
<td style="width:22.52%;">
<p>$a / $b</p>
</td>
</tr><tr><td style="width:29.46%;">
<p>%</p>
</td>
<td style="width:48.02%;">
<p>Залишок від ділення</p>
</td>
<td style="width:22.52%;">
<p>$a % $b</p>
</td>
</tr></tbody></table><p> </p>
<p><strong>Таблиця 2.</strong> Строкові оператори</p>
<table border="1" cellpadding="0" cellspacing="0" style="width:100.0%;" width="100%"><tbody><tr><td style="width:21.82%;">
<p align="center">Позначення</p>
</td>
<td style="width:35.82%;">
<p align="center">Назва</p>
</td>
<td style="width:42.34%;">
<p align="center">Приклад</p>
</td>
</tr><tr><td style="width:21.82%;">
<p align="center"><strong>.</strong></p>
</td>
<td style="width:35.82%;">
<p>Конкатенація (додавання рядків)</p>
</td>
<td style="width:42.34%;">
<p>$c = $a . $b (це рядок, що складається з $a і $b)</p>
</td>
</tr></tbody></table><p> </p>
<p><strong>Таблиця 3.</strong> Оператори присвоювання</p>
<table border="1" cellpadding="0" cellspacing="0" style="width:100.0%;" width="100%"><tbody><tr><td style="width:21.66%;">
<p align="center">Позначення</p>
</td>
<td style="width:21.88%;">
<p align="center">Назва</p>
</td>
<td style="width:31.82%;">
<p align="center">Опис</p>
</td>
<td style="width:24.64%;">
<p align="center">Приклад</p>
</td>
</tr><tr><td style="width:21.66%;">
<p align="center"><strong>=</strong></p>
</td>
<td style="width:21.88%;">
<p>Присвоєння</p>
</td>
<td style="width:31.82%;">
<p>Змінній ліворуч від оператора буде присвоєне значення, отримане в результаті виконання яких-небудь операцій або змінній/константи із правої сторони</p>
</td>
<td style="width:24.64%;">
<p>$a = ($b = 4) +5; ($a буде дорівнювати 9, $b буде дорівнювати 4)</p>
</td>
</tr><tr><td style="width:21.66%;">
<p align="center"><strong>+=</strong></p>
</td>
<td style="width:21.88%;">
<p>Скорочення</p>
</td>
<td style="width:31.82%;">
<p>Додає до змінної число й потім присвоює їй отримане значення</p>
</td>
<td style="width:24.64%;">
<p>$a += 5; (еквівалентно $a = $a + 5;)</p>
</td>
</tr><tr><td style="width:21.66%;">
<p align="center"><strong>.=</strong></p>
</td>
<td style="width:21.88%;">
<p>Назва</p>
</td>
<td style="width:31.82%;">
<p>Скорочено позначає комбінацію операцій конкатенації й присвоювання (спочатку додається рядок, потім отримана рядок записується в змінну)</p>
</td>
<td style="width:24.64%;">
<p>$b = "Привіт "; $b .= "всім"; (еквівалентно $b = $b . "всім";) У результаті: $b="Привіт всім"</p>
</td>
</tr></tbody></table><p> </p>
<p><strong>Таблиця 4.</strong> Логічні оператори</p>
<table border="1" cellpadding="0" cellspacing="0" style="width:100.0%;" width="100%"><tbody><tr><td style="width:21.82%;">
<p align="center">Позначення</p>
</td>
<td style="width:20.46%;">
<p align="center">Назва</p>
</td>
<td style="width:40.86%;">
<p align="center">Опис</p>
</td>
<td style="width:16.86%;">
<p align="center">Приклад</p>
</td>
</tr><tr><td style="width:21.82%;">
<p>And</p>
</td>
<td style="width:20.46%;">
<p>і</p>
</td>
<td style="width:40.86%;">
<p>$a і $b істинні (True)</p>
</td>
<td style="width:16.86%;">
<p>$a and $b</p>
</td>
</tr><tr><td style="width:21.82%;">
<p>&amp;&amp;</p>
</td>
<td style="width:20.46%;">
<p>і</p>
</td>
<td style="width:40.86%;">
<p> </p>
</td>
<td style="width:16.86%;">
<p>$a &amp;&amp; $b</p>
</td>
</tr><tr><td style="width:21.82%;">
<p>Or</p>
</td>
<td style="width:20.46%;">
<p>Або</p>
</td>
<td style="width:40.86%;">
<p>Хоча б одна зі змінних $a або $b істина (можливо, що й обидві)</p>
</td>
<td style="width:16.86%;">
<p>$a or $b</p>
</td>
</tr><tr><td style="width:21.82%;">
<p>||</p>
</td>
<td style="width:20.46%;">
<p>Або</p>
</td>
<td style="width:40.86%;">
<p> </p>
</td>
<td style="width:16.86%;">
<p>$a || $b</p>
</td>
</tr><tr><td style="width:21.82%;">
<p>Xor</p>
</td>
<td style="width:20.46%;">
<p>Що виключає або</p>
</td>
<td style="width:40.86%;">
<p>Одна зі змінних істина. Випадок, коли вони обидві істині, виключається</p>
</td>
<td style="width:16.86%;">
<p>$a xor $b</p>
</td>
</tr><tr><td style="width:21.82%;">
<p>!</p>
</td>
<td style="width:20.46%;">
<p>Інверсія (NOT)</p>
</td>
<td style="width:40.86%;">
<p>Якщо $a=True, то !$a=False і навпаки</p>
</td>
<td style="width:16.86%;">
<p>! $a</p>
</td>
</tr></tbody></table><p> </p>
<p><strong>Таблиця 5.</strong> Оператори порівняння</p>
<table border="1" cellpadding="0" cellspacing="0" style="width:100.0%;" width="100%"><tbody><tr><td style="width:21.84%;">
<p align="center">Позначення</p>
</td>
<td style="width:32.98%;">
<p align="center">Назва</p>
</td>
<td style="width:28.18%;">
<p align="center">Опис</p>
</td>
<td style="width:17.0%;">
<p align="center">Приклад</p>
</td>
</tr><tr><td style="width:21.84%;">
<p>==</p>
</td>
<td style="width:32.98%;">
<p>Рівність</p>
</td>
<td style="width:28.18%;">
<p>Значення змінних рівні</p>
</td>
<td style="width:17.0%;">
<p>$a == $b</p>
</td>
</tr><tr><td style="width:21.84%;">
<p>===</p>
</td>
<td style="width:32.98%;">
<p>Еквівалентність</p>
</td>
<td style="width:28.18%;">
<p>Рівні значення і типи змінних</p>
</td>
<td style="width:17.0%;">
<p>$a === $b</p>
</td>
</tr><tr><td style="width:21.84%;">
<p>!=</p>
</td>
<td style="width:32.98%;">
<p>Нерівність</p>
</td>
<td style="width:28.18%;">
<p>Значення змінних не рівні</p>
</td>
<td style="width:17.0%;">
<p>$a != $b</p>
</td>
</tr><tr><td style="width:21.84%;">
<p>&lt;&gt; </p>
</td>
<td style="width:32.98%;">
<p>Нерівність</p>
</td>
<td style="width:28.18%;">
<p> </p>
</td>
<td style="width:17.0%;">
<p>$a &lt;&gt; $b</p>
</td>
</tr><tr><td style="width:21.84%;">
<p>!==</p>
</td>
<td style="width:32.98%;">
<p>Нееквівалентність</p>
</td>
<td style="width:28.18%;">
<p>Змінні не еквівалентні</p>
</td>
<td style="width:17.0%;">
<p>$a !== $b</p>
</td>
</tr><tr><td style="width:21.84%;">
<p>&lt; </p>
</td>
<td style="width:32.98%;">
<p>Менше</p>
</td>
<td style="width:28.18%;">
<p> </p>
</td>
<td style="width:17.0%;">
<p>$a &lt; $b</p>
</td>
</tr><tr><td style="width:21.84%;">
<p>&gt; </p>
</td>
<td style="width:32.98%;">
<p>Більше</p>
</td>
<td style="width:28.18%;">
<p> </p>
</td>
<td style="width:17.0%;">
<p>$a &gt; $b</p>
</td>
</tr><tr><td style="width:21.84%;">
<p>&lt;=</p>
</td>
<td style="width:32.98%;">
<p>Менше або дорівнює</p>
</td>
<td style="width:28.18%;">
<p> </p>
</td>
<td style="width:17.0%;">
<p>$a &lt;= $b</p>
</td>
</tr><tr><td style="width:21.84%;">
<p>&gt;=</p>
</td>
<td style="width:32.98%;">
<p>Більше або дорівнює</p>
</td>
<td style="width:28.18%;">
<p> </p>
</td>
<td style="width:17.0%;">
<p>$a &gt;= $b</p>
</td>
</tr></tbody></table><p> </p>
<p><strong>Таблиця 6.</strong> Оператори інкремента й декремента</p>
<table border="1" cellpadding="0" cellspacing="0" style="width:100.0%;" width="100%"><tbody><tr><td style="width:21.82%;">
<p align="center">Позначення</p>
</td>
<td style="width:22.9%;">
<p align="center">Назва</p>
</td>
<td style="width:38.6%;">
<p align="center">Опис</p>
</td>
<td style="width:16.68%;">
<p align="center">Приклад</p>
</td>
</tr><tr><td style="width:21.82%;">
<p>++$a</p>
</td>
<td style="width:22.9%;">
<p>Пре-Інкремент</p>
</td>
<td style="width:38.6%;">
<p>Збільшує $a на одиницю й повертає $a</p>
</td>
<td style="width:16.68%;">
<p> </p>
</td>
</tr><tr><td style="width:21.82%;">
<p>$a++</p>
</td>
<td style="width:22.9%;">
<p>Пост-інкремент</p>
</td>
<td style="width:38.6%;">
<p>Повертає $a, потім збільшує $a на одиницю</p>
</td>
<td style="width:16.68%;">
<p> </p>
</td>
</tr><tr><td style="width:21.82%;">
<p>--$a</p>
</td>
<td style="width:22.9%;">
<p>Пре-декремент</p>
</td>
<td style="width:38.6%;">
<p>Зменшує $a на одиницю й повертає $a</p>
</td>
<td style="width:16.68%;">
<p> </p>
</td>
</tr><tr><td style="width:21.82%;">
<p>$a--</p>
</td>
<td style="width:22.9%;">
<p>Пост-декремент</p>
</td>
<td style="width:38.6%;">
<p>Повертає $a, потім зменшує $a на одиницю</p>
</td>
<td style="width:16.68%;">
<p> </p>
</td>
</tr></tbody></table><p> </p>
<h1 align="center">Типи даних</h1>
<p>PHP підтримує вісім простих типів даних.</p>
<p><strong>Чотири скалярних типи:</strong></p>
<ul><li>boolean (логічні дані)</li>
</ul><ul><li>integer (цілі числа)</li>
</ul><ul><li>float (число з плаваючою крапкою або 'double')</li>
</ul><ul><li>string (рядки)</li>
</ul><p><strong>Два змішаних типу:</strong></p>
<ul><li>array (масиви)</li>
</ul><ul><li>object (об'єкти)</li>
</ul><p><strong>І два спеціальних типи:</strong></p>
<ul><li>resource (ресурси)</li>
</ul><ul><li>NULL (порожній тип)</li>
</ul><p>Існують також кілька <strong>псевдотипів:</strong></p>
<ul><li>mixed (змішаний тип)</li>
</ul><ul><li>number (числа)</li>
</ul><ul><li>callback (зворотного виклику)</li>
</ul><p>У PHP не прийнято явне оголошення типів змінних. Переважно, це робить сам інтерпретатор під час виконання програми в залежності від контексту, в якому використовується змінна. Розглянемо по порядку всі перераховані типи даних.</p>
<p> </p>
<h1 align="center">Тип boolean (логічний тип)</h1>
<p>Цей найпростіший тип, що висловлює істинність значення, тобто змінна цього типу може мати лише два значення - істина TRUE або брехня FALSE.</p>
<p>Щоб визначити логічний тип, використовують ключове слово TRUE або FALSE. Обидва регістронезалежні.</p>
<p><strong>Приклад 4.</strong> Логічний тип</p>
<p style="margin-left:14.2pt;">&lt;? Php   <br />$Test = True;  <br />?&gt;</p>
<p>Логічні змінні використовуються в різних управляючих конструкціях (циклах, умовах тощо). Мати логічний тип, тобто приймати тільки два значення, істину, чи брехню, можуть також і деякі оператори (наприклад, оператор рівності). Вони також використовуються в керуючих конструкціях для перевірки будь-яких умов. Наприклад, в умовній конструкції перевіряється істинність значення оператора або змінної і залежно від результату перевірки виконуються ті чи інші дії. Тут умова може бути істинно або хибно, що якраз і відображає змінна і оператор логічного типу.</p>
<p><strong>Приклад 5.</strong> Використання логічного типу</p>
<p>&lt;? Php  <br />// Оператор '==' перевіряє рівність        <br />// І повертає       <br />// Булеве значення       <br />if ($ know == False) {// якщо $know       <br />// Має значення  <br />// False       <br />echo "Вивчай PHP!";   <br />}       <br />if (!$know) {/ / те ж саме, що<br />// І вище, тобто перевірка    <br />// Чи має $know значення    <br />// False       <br />echo "Вивчай PHP!";   <br />}       <br />/* Оператор == перевіряє, чи збігається         <br />значення змінної $know з рядком<br />"Вивчити PHP". Якщо співпадає, то      <br />повертає true, інакше - false.<br />Якщо повернуто true, то виконується   <br />те, що всередині фігурних дужок * /     <br />if ($know == "Вивчити PHP")       <br />{Echo "Почав вивчати";}     <br />?&gt;</p>
<p> </p>
<h1 align="center">Тип integer (цілі)</h1>
<p>Цей тип задає число з множини цілих чисел Z = {..., -2, -1, 0, 1, 2, ...}. Цілі можуть бути вказані у десятковій, шістнадцятковій або вісімковій системі числення, за бажанням з попереднім знаком «-» або «+».</p>
<p>Якщо ви використовуєте вісімкову систему числення, ви повинні перед числом ставити 0 (нуль), для використання шістнадцяткової системи потрібно поставити перед числом 0x.</p>
<p style="margin-left:14.2pt;">&lt;? Php  <br /># Десяткове число   <br />$A = 1234;     <br /># Від'ємне число     <br />$A = -123;      <br /># Вісімкове число (еквівалентно        <br /># 83 у десятковій системі)<br />$A = 0123;     <br /># Шістнадцяткове число (еквівалентно       <br /># 26 у десятковій системі)<br />$A = 0x1A;     <br />?&gt;</p>
<p>Розмір цілого залежить від платформи, хоча, як правило, максимальне значення близько двох мільярдів (це 32-бітове знакове). Беззнакові цілі PHP не підтримує.</p>
<p>Якщо ви визначите число, що перевищує межі цілого типу, воно буде інтерпретовано як число з плаваючою крапкою. Також якщо ви використовуєте оператор, результатом роботи якого буде число, що перевищує межі цілого, замість нього буде повернуто число з плаваючою крапкою.</p>
<p>У PHP не існує оператора ділення цілих. Результатом 1/2 буде число з плаваючою крапкою 0.5. Ви можете навести значення до цілого, що завжди округлює його в меншу сторону, або використовувати функцію round (), округлюються значення за стандартними правилами. Для перетворення змінної до конкретного типу потрібно перед змінною вказати в дужках потрібний тип. Наприклад, для перетворення змінної $a = 0.5 до цілого типу необхідно написати (integer) (0.5) або (integer) $a або використовувати скорочений запис (int) (0.5). Можливість явного приведення типів за таким принципом існує для всіх типів даних (звичайно, не завжди значення одного типу можна перевести в інший тип). Ми не будемо заглиблюватися у всі тонкощі приведення типів, оскільки PHP робить це автоматично залежно від контексту.</p>
<p> </p>
<h1 align="center">Тип float (числа з плаваючою крапкою)</h1>
<p>Числа з плаваючою крапкою (вони ж числа подвійної точності або дійсні числа) можуть бути визначені за допомогою будь-якого з наступних синтаксисів:</p>
<p style="margin-left:14.2pt;">&lt;? Php  <br />$ A = 1.234;   <br />$ B = 1.2e3;    <br />$ C = 7E-10;   <br />?&gt;</p>
<p>Розмір числа з плаваючою крапкою залежить від платформи, хоча максимум, як правило, ~ 1.8e308 з точністю близько 14 десяткових цифр.</p>
<h1 align="center">Тип string (рядки)</h1>
<p><strong>Рядок</strong> - це набір символів. У PHP символ - це те ж саме, що байт, це означає, що існує рівно 256 різних символів. Це також означає, що PHP не має вбудованої підтримки Unicode. У PHP практично не існує обмежень на розмір рядків, тому немає абсолютно ніяких причин турбуватися про їх довжину.</p>
<p>Рядок у PHP може бути визначений <strong>трьома різними</strong> способами:</p>
<ul><li>за допомогою одинарних лапок;</li>
</ul><ul><li>за допомогою подвійних лапок;</li>
</ul><ul><li>heredoc-синтаксисом.</li>
</ul><h3 align="center">Одинарні лапки</h3>
<p>Найпростіший спосіб <strong>визначити рядок</strong> - це розмістити його в одинарні лапки «'». Щоб використовувати одинарні лапки всередині рядка, як і в багатьох інших мовах, перед нею необхідно поставити символ зворотної косої межі «\», тобто екранувати її. Якщо зворотній слеш повинен йти перед одинарними лапками або бути в кінці рядка, необхідно продублювати його «\\ '».</p>
<p>Якщо всередині рядка, розміщеного в одинарні лапки, зворотній слеш «\» зустрічається перед будь-яким іншим символом (відмінним від «\» і «'»), то він розглядається як звичайний символ і виводиться, як і всі інші. Тому зворотну косу риску необхідно екранувати, тільки якщо вона знаходиться в кінці рядка, перед останньою лапкою.</p>
<p>У PHP існує ряд комбінацій символів, які починаються з символу зворотнього косого слеша. Їх називають управляючими послідовностями, і вони мають спеціальні значення, про які ми розповімо трохи пізніше. Так от, на відміну від двох інших синтаксисів, змінні і керуючі послідовності для спеціальних символів, що зустрічаються в рядках, взятих в одинарні лапки, не обробляються.</p>
<p style="margin-left:14.2pt;"><strong>Приклад 6.</strong> Використання керуючих послідовностей</p>
<p style="margin-left:14.2pt;">&lt;? Php<br />echo 'Також ви можете додавати до рядка<br />символ нового рядка таким чином,<br />це нормально ';<br />// Виведе: Щоб вивести ' треба<br />// Перед нею поставити \<br />echo 'Щоб вивести \' треба перед '.<br />'Нею поставити \\'; <br />// Виведе: Ви хочете видалити C: \ *.*?<br />echo 'Ви хочете видалити C: \ \ *.*?';<br />// Виведе: Це не вставить: \ n новий рядок<br />echo 'Це не вставить: \ n новий рядок';<br />// Виведе: Змінні $ expand також<br />// $Either не підставляються<br />echo 'Змінні $ expand також $ either'.<br />'Не підставляються';<br />?&gt;</p>
<h3 align="center">Подвійні лапки</h3>
<p>Якщо рядок помістити у подвійні лапки «" », то PHP розпізнає більшу кількість керуючих послідовностей для спеціальних символів. Деякі з них наведені в таблиці 7.</p>
<table border="1" cellpadding="0" cellspacing="0" style="width:100.0%;" width="100%"><tbody><tr><td style="width:31.96%;">
<p align="center">Послідовність</p>
</td>
<td style="width:68.06%;">
<p align="center">Значення</p>
</td>
</tr><tr><td style="width:31.96%;">
<p>\n</p>
</td>
<td style="width:68.06%;">
<p>Новий рядок (LF або 0x0A (10) в ASCII)</p>
</td>
</tr><tr><td style="width:31.96%;">
<p>\r</p>
</td>
<td style="width:68.06%;">
<p>Повернення каретки (CR або 0x0D (13) в ASCII)</p>
</td>
</tr><tr><td style="width:31.96%;">
<p>\t</p>
</td>
<td style="width:68.06%;">
<p>Горизонтальна табуляція (HT або 0x09 (9) в ASCII)</p>
</td>
</tr><tr><td style="width:31.96%;">
<p>\\</p>
</td>
<td style="width:68.06%;">
<p>Зворотній слеш</p>
</td>
</tr><tr><td style="width:31.96%;">
<p>\$</p>
</td>
<td style="width:68.06%;">
<p>Знак долара</p>
</td>
</tr><tr><td style="width:31.96%;">
<p>\"</p>
</td>
<td style="width:68.06%;">
<p>Подвійна лапки</p>
</td>
</tr></tbody></table><p>Найважливішою властивістю рядків у подвійних лапках є обробка змінних.</p>
<h3 align="center">Heredoc</h3>
<p>Інший спосіб визначення рядків - це використання <strong>heredoc-синтаксису</strong>. У цьому випадку рядок повинен починатися з символу &lt;&lt;, після якого йде ідентифікатор. Закінчується рядок цим самим ідентифікатором. Закриваючий ідентифікатор повинен починатися в першому стовпці рядка. Крім того, ідентифікатор повинен відповідати тим же правилам іменування, що і всі інші позначки в PHP: містити тільки буквено-цифрові символи і знак підкреслення та починатися з цифри або знака підкреслення.</p>
<p><strong>Heredoc</strong>-текст веде себе так само, як і рядок в подвійних лапках, при цьому їх не маючи. Це означає, що вам немає необхідності екранувати лапки в heredoc, але ви як і раніше можете використовувати перераховані вище керуючі послідовності. Змінні всередині heredoc теж обробляються.</p>
<p><strong>Приклад 7.</strong> Використання heredoc-синтаксису <br />&lt;? Php <br />$Str = &lt;&lt;<br />Приклад рядка, що охоплює кілька <br />рядків, з використанням <br />heredoc-синтаксису <br />EOD; <br />// Тут ідентифікатор – EOD використовується як маркер завершення даних.</p>
<p>$Name = 'Вася'; <br />echo &lt;&lt;<br />Мене звуть "$name". <br />EOD; <br />// Це виведе "Мене звуть" Вася ". <br />?&gt; </p>
<p> </p>
<p><strong>Зауваження:</strong> Підтримка heredoc була додана з PHP 4. </p>
<h1 align="center"> </h1>
<h1 align="center">Тип array (масив)</h1>
<p><strong>Масиви (arrays)</strong> - це впорядковані набори даних, що представляють собою список однотипних елементів.</p>
<p><em>Існує два типи масивів, що розрізняються за способом ідентифікації елементів.</em></p>
<ol><li>У масивах першого типу елемент визначається індексом у послідовності. Такі масиви називаються простими масивами.</li>
<li>Масиви другого типу мають асоціативну природу, і для звернення до елементів використовуються ключі, логічно пов'язані зі значеннями. Такі масиви називають асоціативними масивами.</li>
</ol><p>Важливою особливістю PHP є те, що PHP, на відміну від інших мов, дозволяє створювати масиви будь-якої складності безпосередньо в тілі програми (скрипта).</p>
<p>Масиви можуть бути як одновимірними, так і багатовимірними.</p>
<h1 align="center">Прості масиви та списки в PHP</h1>
<p>При зверненні до елементів простих індексованих масивів використовується цілочисельний індекс, що визначає позицію заданого елемента.</p>
<h3 align="center">Прості одномірні масиви:</h3>
<p>Узагальнений синтаксис елементів простого одновимірного масиву:</p>
<p>$Ім'я [індекс];</p>
<p>Масиви, індексами яких є числа, які починаються з нуля – це списки:</p>
<p style="margin-left:14.2pt;">&lt;? Php  <br />/ / Простий спосіб ініціалізації масиву        <br />$Names [0] = "Апельсин";         <br />$Names [1] = "Банан";      <br />$Names [2] = "Груша";    <br />$Names [3] = "Помідор"; <br />// Тут: Names - ім'я масиву, а 0, 1, 2, 3 - індекси масиву        <br />?&gt;</p>
<p>Доступ до елементів простих масивів (списків) здійснюється наступним чином:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />// Простий спосіб ініціалізації масиву <br />$Names [0] = "Апельсин"; <br />$Names [1] = "Банан"; <br />$Names [2] = "Груша"; <br />$Names [3] = "Помідор"; <br />// Тут: Names - ім'я масиву, а 0, 1, 2, 3 - індекси масиву <br /><br />/ /Виведемо елементи масивів в браузер: <br />echo $Names [0]; // Значення елемента масиву names з індексом 0 <br />echo $Names [3]; // Значення елемента масиву names з індексом 3 <br />// Виводить: <br />// Апельсин <br />// Помідор <br />?&gt;</p>
<p>З технічної точки зору різниці між простими масивами і списками немає.</p>
<p>Прості масиви можна створювати, не вказуючи індекс нового елемента масиву, це за вас зробить PHP. Ось приклад:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />// Простий спосіб ініціалізації масиву, без вказівки індексів <br />$Names [] = "Апельсин"; <br />$Names [] = "Банан"; <br />$Names [] = "Груша"; <br />$Names [] = "Помідор"; <br />// PHP автоматично присвоїть індекси елементів масиву, починаючи з 0 <br /><br />// Виводимо елементи масивів в браузер: <br />echo $Names [0]; // Висновок елемента масиву names з індексом 0 <br />echo $Names [3]; // Висновок елемента масиву names з індексом 3 <br />// Виводить: <br />// Апельсин <br />// Помідор <br />?&gt;</p>
<p>У розглянутому прикладі ви можете додавати елементи масиву Names простим способом, тобто не вказуючи індекс елемента масиву:</p>
<p align="center">$Names [] = "Яблуко";</p>
<p>Новий елемент простого масиву (списку) буде додано в кінець масиву. Надалі, з кожним новим елементом масиву, індекс буде збільшуватися на одиницю.</p>
<h3 align="center">Прості багатовимірні масиви:</h3>
<p>Узагальнений синтаксис елементів багатовимірного простого масиву:</p>
<p align="center">$Ім'я [індекс1] [індекс2] .. [індексN];</p>
<p><strong>Приклад простого багатовимірного масиву:</strong></p>
<p style="margin-left:14.2pt;">&lt;? Php <br />// Багатомірний простий масив: <br />$Arr [0] [0] = "Овочі"; <br />$Arr [0] [1] = "Фрукти"; <br />$Arr [1] [0] = "Абрикос"; <br />$Arr [1] [1] = "Апельсин"; <br />$Arr [1] [2] = "Банан"; <br />$Arr [2] [0] = "Огірок"; <br />$Arr [2] [1] = "Помідор"; <br />$Arr [2] [2] = "Гарбуз"; <br /><br />// Виводимо елементи масиву: <br />echo "&lt;h3&gt;". $Arr [0] [0 ].":&lt;/ h3&gt; "; <br />for ($q = 0; $q &lt;= 2; $q + +) { <br />echo $Arr [2] [$ q]. ""; <br />} <br />echo "&lt;h3&gt;". $Arr [0] [1 ].":&lt;/ h3&gt; "; <br />for ($w = 0; $w &lt;= 2; $w + +) { <br />echo $Arr [1] [$ w]. "&lt;br&gt;"; <br />} <br />?&gt; </p>
<h3 align="center">Асоціативні масиви в PHP</h3>
<p>У PHP індексом масиву може бути не тільки число, але і рядок. Причому на такий рядок не накладаються ніякі обмеження: він може містити пробіли, довжина такого рядка може бути будь-яка.</p>
<p>Асоціативні масиви особливо зручні в ситуаціях, коли елементи масиву зручніше пов'язувати зі словами, а не з числами.</p>
<p>Отже, масиви, індексами яких є рядки, називаються асоціативними масивами.</p>
<p align="center"><strong>Одномірні асоціативні масиви:</strong></p>
<p>Одномірні асоціативні масиви містять тільки один ключ (елемент), відповідний конкретному індексу асоціативного масиву. Наведемо <strong>приклад:</strong></p>
<p style="margin-left:14.2pt;">&lt;? Php <br />// Асоціативний масив <br />$Names ["Іванов"] = "Іван"; <br />$Names ["Сидоров"] = "Микола"; <br />$Names ["Петров"] = "Петро"; <br />// У даному прикладі: прізвища - ключі асоціативного масиву <br />//, А імена - елементи масиву Names <br />?&gt;</p>
<p>Доступ до елементів одновимірних асоціативних масивів здійснюється так само, як і до елементів звичайних масивів, і називається доступом по ключу:</p>
<p align="center">echo $Names ["Іванов"];</p>
<h3 align="center">Багатовимірні асоціативні масиви:6</h3>
<p>Багатовимірні асоціативні масиви можуть містити кілька ключів, які відповідають конкретним індексам асоціативного масиву. Розглянемо приклад багатовимірного асоціативного масиву:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />// Багатомірний масив <br />$A ["Ivanov"] = array ("name" =&gt; "Іванов І.І.", "age" =&gt; "25", "email" =&gt; "<a href="mailto:ivanov@mail.ru">ivanov@mail.ru</a>"); <br />$A ["Petrov"] = array ("name" =&gt; "Петров П.П.", "age" =&gt; "34", "email" =&gt; "<a href="mailto:petrov@mail.ru">petrov@mail.ru</a>"); <br />$A ["Sidorov"] = array ("name" =&gt; "Сидоров С.С.", "age" =&gt; "47", "email" =&gt; "<a href="mailto:sidorov@mail.ru">sidorov@mail.ru</a>"); <br />?&gt;</p>
<p>Багатовимірні масиви схожі на записи у мові Pascal або структури в мові C.</p>
<p>Доступ до елементів багатовимірного асоціативного масиву здійснюється наступним чином:</p>
<p style="margin-left:14.2pt;">echo $A ["Ivanov"] ["name"]; // Виводить Іванов І.І. <br />echo $A ["Petrov"] ["email"]; // Виводить <a href="mailto:petrov@mail.ru">petrov@mail.ru</a></p>
<p>Як ви вже помітили, для створення багатовимірного асоціативного масиву ми використовували спеціальну функцію array, ми її розглянемо пізніше, коли будемо розглядати операції над масивами.</p>
<p>Асоціативні багатовимірні масиви можна створювати і класичним способом, хоча це не так зручно:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />// Багатомірний асоціативний масив <br />$A ["Ivanov"] ["name"] = "Іванов І.І."; <br />$A ["Ivanov"] ["age"] = "25"; <br />$A ["Ivanov"] ["email"] = "<a href="mailto:ivanov@mail.ru">ivanov@mail.ru</a>"; <br /><br />$A ["Petrov"] ["name"] = "Петров П.П."; <br />$A ["Petrov"] ["age"] = "34"; <br />$A ["Petrov"] ["email"] = "<a href="mailto:petrov@mail.ru">petrov@mail.ru</a>"; <br /><br />$A ["Sidorov"] ["name"] = "Сидоров С.С."; <br />$A ["Sidorov"] ["age"] = "47"; <br />$A ["Sidorov"] ["email"] = "<a href="mailto:sidorov@mail.ru">sidorov@mail.ru</a>"; <br /><br />// Отримуємо доступ до ключів багатовимірного асоціативного масиву <br />echo $A ["Ivanov"] ["name "]."&lt; br&gt;"; // Виводить Іванов І.І. <br />echo $A ["Sidorov"] ["age "]."&lt; br&gt;"; // Виводить 47 <br />echo $A ["Petrov"] ["email "]."&lt; br&gt;"; // Виводить <a href="mailto:petrov@mail.ru">petrov@mail.ru</a> <br />?&gt;</p>
<h3 align="center">Тип object (об'єкти)</h3>
<p><strong>Об'єкти</strong> - тип даних, що прийшов з об'єктно-орієнтованого програмування (ООП). Згідно з принципами ООП, клас - це набір об'єктів, що володіють певними властивостями і методами роботи з ним, а об'єкт відповідно - екземпляр класу. Наприклад, програмісти - це клас людей, які пишуть програми, вивчають комп'ютерну літературу і, крім того, як всі люди, мають ім'я та прізвище. Тепер, якщо взяти одного конкретного програміста, Васю Іванова, то можна сказати, що він є об'єктом класу програмістів, має ті ж властивості, що й інші програмісти, теж має ім'я, пише програми і т.п.</p>
<p>У PHP для доступу до методів об'єкта використовується оператор -&gt;. Для ініціалізації об'єкту використовується вираз new, що створює в змінній екземпляр об'єкта.</p>
<p style="margin-left:14.2pt;"><strong>Приклад 8.</strong> Об'єкти в PHP</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />// Створюємо клас людей <br />class Person <br />{ <br />// Метод, який навчає людину PHP <br />function know_php () <br />{ <br />echo "Тепер я знаю PHP"; <br />} <br />} <br />$Bob = new Person; // створюємо об'єкт <br />// Класу людина <br />$ Bob -&gt; know_php (); // навчаємо його PHP <br />?&gt;</p>
<p>Більш докладно реалізацію принципів ООП в мові PHP ми розглянемо в одній з наступних лекцій.</p>
<p> </p>
<h3 align="center">Тип resource (ресурси)</h3>
<p><strong>Ресурс </strong>- це спеціальна змінна, що містить посилання на зовнішній ресурс (наприклад, з'єднання з базою даних). Ресурси створюються та використовуються спеціальними функціями (наприклад, mysql_connect (), pdf_new () і т.п.).</p>
<p align="center"><strong>Тип Null</strong></p>
<p>Спеціальне значення NULL говорить про те, що змінна не має значення.</p>
<p>Змінна вважається NULL, якщо:</p>
<ul><li>їй була присвоєна константа NULL ($var = NULL);</li>
<li>їй ще не було присвоєно будь-яке значення;</li>
<li>вона була вилучена за допомогою unset ().</li>
</ul><p>Існує тільки одне значення типу NULL - регістронезалежне ключове слово NULL.</p>
<h3 align="center">Керуючі конструкції</h3>
<p align="center"><strong>Умовні оператори</strong></p>
<p align="center"><strong>Оператор if</strong></p>
<p>Це один з найважливіших операторів багатьох мов, включаючи PHP. Він дозволяє виконувати фрагменти коду в залежності від умови. Структуру оператора if можна представити наступним чином:</p>
<p>if (вираз) блок_виконання</p>
<p>Тут вираз є будь-який правильний PHP-вираз (тобто все, що має значення). У процесі обробки скрипта вираз перетвориться до логічного типу. Якщо в результаті перетворення значення виразу істинно (True), то виконується блок_виконання. В іншому випадку блок_виконання ігнорується. Якщо блок_виконання містить кілька команд, то він повинен бути укладений у фігурні дужки {}.</p>
<p><strong><em>Правила перетворення виразу до логічного типу:</em></strong> <br />1. Правила перетворення виразу до логічного типу:</p>
<ul style="list-style-type:circle;"><li>логічне False</li>
</ul><ul style="list-style-type:circle;"><li>цілий нуль (0)</li>
</ul><ul style="list-style-type:circle;"><li>дійсний нуль (0.0)</li>
</ul><ul style="list-style-type:circle;"><li>порожній рядок і рядок "0"</li>
</ul><ul style="list-style-type:circle;"><li>масив без елементів</li>
</ul><ul style="list-style-type:circle;"><li>об'єкт без змінних (детально про об'єкти буде розказано в одній з наступних лекцій)</li>
</ul><ul style="list-style-type:circle;"><li>спеціальний тип NULL</li>
</ul><p> </p>
<p>2. Всі інші значення перетворюються в TRUE.</p>
<p> </p>
<p><strong>Приклад 9.</strong> Умовний оператор if</p>
<p>&lt;? <br />$Names = array ("Іван", "Петро", "Семен"); <br />if ($Names[0] == "Іван") { <br />echo "Привіт, Ваня!"; <br />$Num = 1; <br />$Account = 2000; <br />} <br />if ($num) echo "Іван перший у списку!"; <br />$Bax = 30; <br />if ($Account &gt; 100 * $Bax +3) <br />echo "Цей рядок не з'явиться <br />на екрані, так як умова не виконана "; <br />?&gt;</p>
<p> </p>
<h3 align="center">Оператор else</h3>
<p>Ми розглянули тільки одну, основну частину оператора if. Існує кілька розширень цього оператора. Оператор else розширює if на випадок, якщо вираз, що перевіряється в if є невірним, і дозволяє виконати будь-які дії за таких умов.</p>
<p>Структуру оператора if, розширеного за допомогою оператора else, можна представити таким чином:</p>
<p align="center">if (вираз) блок_виконання<br />else блок_виконання1</p>
<p>Цю конструкцію if ... else можна інтерпретувати приблизно так: якщо виконана умова (тобто вираз = true), то виконуємо дії з блоку_виконання, інакше - дії з блоку_виконання1. Використовувати оператор else не обов'язково.</p>
<p>Подивимося, як можна змінити попередній приклад, з огляду на необхідність здійснення дій в разі невиконання умови.</p>
<p style="margin-left:14.2pt;"><strong>Приклад 10.</strong> Оператор else</p>
<p style="margin-left:14.2pt;">&lt;? <br />$Names = array ("Іван", "Петро", "Семен"); <br />if ($Names [0] == "Іван") { <br />echo "Привіт, Ваня!"; <br />$Num = 1; <br />$Account = 2000; <br />}Else { <br />echo "Привіт, $Names [0]. <br />А ми чекали Ваню: ("; <br />} <br />if ($Num) echo "Іван перший у списку!"; <br />else echo "Іван НЕ перший у списку?!"; <br />$Bax = 30; <br />if ($Account &gt; 100 * $ bax +3) <br />echo "Цей рядок не з'явиться на екрані, <br />так як умова не виконана "; <br />else echo "Зате з'явиться цей рядок!"; <br />?&gt; <br /> </p>
<h3 align="center">Оператор elseif</h3>
<p>Ще один спосіб розширення умовного оператора if - використання оператора elseif. Еlseif - це комбінація else і if. Як і else, він розширює if для виконання різних дій у тому випадку, якщо умова, що перевіряється в if, невірно. Але на відміну від else, альтернативні дії будуть виконані, тільки якщо elseif-умова є вірним. Структуру оператора if, розширеного за допомогою операторів else і elseif, можна представити таким чином:</p>
<p>if (вираз) блок_виконання</p>
<p>elseif (вираз1) блок_виконання1</p>
<p>...</p>
<p>else блок_ виконанняN</p>
<p>Операторів elseif може бути відразу кілька в одному if-блоці. Elseif-твердження буде виконано, тільки якщо попереднє if-умова є False, всі попередні elseif-умови є False, а дане elseif-умова - True.</p>
<p style="margin-left:14.2pt;"><strong>Приклад 11.</strong> Оператор elseif</p>
<p style="margin-left:14.2pt;">&lt;? <br />$Names = array ("Іван", "Петро", "Семен"); <br />if ($Names [0] == "Іван") { <br />// Якщо перше ім'я в масиві Іван <br />echo "Привіт, Ваня!"; <br />} Elseif ($Names [0] == "Петро") { <br />// Якщо перше ім'я <br />// Не Іван, а Петро <br />echo "Привіт, Петя!"; <br />} Elseif ($Names [0] == "Семен") { <br />// Якщо перше ім'я не <br />// Іван, не Петро, а Семен <br />echo "Привіт, Сеня!"; <br />} Else { <br />// Якщо перше ім'я не Іван, <br />// Не Петро І не Семен <br />echo "Привіт, $ Names [0]. А ти хто такий?"; <br />} <br />?&gt; <br /> </p>
<h3 align="center">Оператор switch</h3>
<p>Ще одна конструкція, що дозволяє перевіряти умови і виконувати в залежності від цього різні дії, - це <strong>switch</strong>. У залежності від того, яке значення має змінна, він перемикається між різними блоками дії. switch дуже схожий на оператор if ... elseif ... else або набір операторів if. Структуру switch можна записати наступним чином:</p>
<p style="margin-left:14.2pt;">switch (вираз чи змінна) { <br />case значення1: <br />блок_дій1 <br />break; <br />case значення2: <br />блок_дій2 <br />break;<br /> ... <br />default: <br />блок_дій_при_замовчуванні <br />}</p>
<p>На відміну від if, тут значення виразу не приводиться до логічного типу, а просто порівнюється зі значеннями, перерахованими після ключових слів case (значення1, значення2 і т.д.). Якщо значення виразу співпало з якимсь варіантом, то виконується відповідний блок_дій - від двокрапки після значення, що співпало до кінця switch або до першого оператора break, якщо такий знайдеться. Якщо значення виразу не співпало з жодним із варіантів, то виконуються дії за умовчанням (блок_дій_при_замовчуванні), що знаходяться після ключового слова default. Вираз в switch обчислюється тільки один раз, а в операторі elseif - кожен раз, тому, якщо вираз досить складний, то switch працює швидше.</p>
<p><strong>Приклад 11</strong> можна переписати з використанням <strong>switch </strong>наступним чином:</p>
<p style="margin-left:14.2pt;">&lt;? <br />$ Names = array ("Іван", "Петро", "Семен"); <br />switch ($Names [0]) { <br />case "Іван": <br />echo "Привіт, Ваня!"; <br />break; <br />case "Петро": <br />echo "Привіт, Петя!"; <br />break; <br />case "Семен": <br />echo "Привіт, Сеня!"; <br />break; <br />default: <br />echo "Привіт, $Names [0]. <br />А як Вас звати? "; <br />} ?&gt;</p>
<p>Якщо в цьому прикладі опустити оператор break, наприклад, в case "Петро":, то, якщо змінна виявиться рівною рядку "Петро", після виведення на екран повідомлення "Привіт, Петя!" програма піде далі і виведе також повідомлення "Привіт, Сеня!" і тільки потім, зустрівши break, продовжить своє виконання за межами switch.</p>
<p>Для конструкції switch, як і для if, можливий альтернативний синтаксис, де відкривається switch фігурна дужка замінюється двокрапкою, а закриває - endswitch; відповідно.</p>
<p> </p>
<h3 align="center">Цикли</h3>
<p>У PHP існує кілька конструкцій, що дозволяють виконувати повторювані дії в залежності від умови. Це цикли while, do .. while, foreach та for. Розглянемо їх більш докладно.</p>
<h3 align="center">while</h3>
<p style="margin-left:14.2pt;">Структура: <br />while (вираз) {блок_виконання} <br />або <br />while (вираз): блок_виконання endwhile;</p>
<p><strong>While</strong> - простий цикл. Він наказує PHP виконувати команди блоку_виконання до тих пір, поки вираз обчислюється як True (тут, як і в if, відбувається приведення вислову до логічного типу). Значення виразу перевіряється щоразу на початку циклу, так що, навіть якщо його значення змінилося в процесі виконання блоку_виконання, цикл не буде зупинено до кінця ітерації (тобто поки всі команди блоку_виконання не будуть виконані).</p>
<p style="margin-left:14.2pt;"><strong>Приклад 12.</strong> Оператор while</p>
<p style="margin-left:14.2pt;">&lt;? <br />// Ця програма надрукує всі парні цифри <br />$I = 1; <br />while ($I &lt;10) { <br />if ($I % 2 == 0) print $ i; <br />// Друкуємо цифру, якщо вона парна <br />$I + +; <br />// І збільшуємо $I на одиницю <br />} <br />?&gt;</p>
<h3 align="center">do ... while</h3>
<p>Цикли do .. while дуже схожі на цикли while, з тією лише різницею, що істинність висловлювання перевіряється наприкінці циклу, а не на початку. Завдяки цьому блок_виконання циклу <strong>do ... while</strong> гарантовано виконується хоча б один раз.</p>
<p><strong>Структура:</strong> <br />do {блок_виконання} while (вираз); <br /><strong>Приклад 13.</strong> Оператор do .. while</p>
<p style="margin-left:14.2pt;">// Ця програма надрукує число 12, незважаючи на те <br />// Що умова циклу не виконано <br />$I = 12; <br />do { <br />if ($I % 2 == 0) print $I; <br />// Якщо число парне, то друкуємо його <br />$I++; <br />// Збільшуємо число на одиницю <br />} While ($I &lt;10)<br />?&gt;</p>
<h3 align="center">for</h3>
<p>Це найскладніші цикли в PHP. Вони нагадують відповідні цикли C.</p>
<p style="margin-left:14.2pt;"><strong>Структура:</strong> <br />for (вираз1; вираз2; вираз3) {блок_виконання} <br />або <br />for (вираз1; вираз2; вираз3): блок_виконання endfor;</p>
<p>Тут, як ми бачимо, умова складається одразу з трьох виразів. Перший вираз вираз1 обчислюється безумовно один раз на початку циклу. На початку кожної ітерації обчислюється вираз2. Якщо він є True, то цикл продовжується і виконуються всі команди блоку_виконання. Якщо вираз2 обчислюється як False, то виконання циклу зупиняється. В кінці кожної ітерації (тобто після виконання всіх команд блоку_виконання) обчислюється вираз3.</p>
<p>Кожне з виразів 1, 2, 3 може бути порожнім. Якщо вираз2 є порожнім, то це значить, що цикл повинен виконуватися невизначений час (у цьому випадку PHP вважає це вираз завжди істинним). Це не так марно, як здається, адже цикл можна зупиняти, використовуючи оператор break.</p>
<p>Наприклад, всі парні цифри можна вивести з використанням циклу for таким чином:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />for ($i = 0; $ i &lt;10; $i + +) { <br />if ($i% 2 == 0) print $i; <br />// Друкуємо парні числа <br />} ?&gt;</p>
<p>Якщо опустити другий вираз (умова $ i &lt;10), то таку ж задачу можна вирішити, зупиняючи цикл оператором break.</p>
<p style="margin-left:14.2pt;">&lt; ? Php <br />for ($i = 0;; $ i + +) { <br />if ($i&gt; = 10) break; <br />// Якщо $i більше або дорівнює 10, <br />// То припиняємо роботу циклу <br />if ($i% 2 == 0) print $ i; <br />// Якщо число парне, <br />// То друкуємо його <br />} ?&gt;</p>
<p>Можна опустити всі три вирази. У цьому випадку просто не буде задано початкове значення лічильника $i і воно не буде змінюватися кожного разу наприкінці циклу. Всі ці дії можна записати у вигляді окремих команд або в блоці_виконання, або перед циклом:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />$і = 2; // задаємо початкове значення лічильника <br />for (;;) { <br />if ($i&gt; = 10) break; <br />// Якщо $i більше або дорівнює 10, <br />// То припиняємо роботу циклу <br />if ($ i% 2 == 0) print $i; <br />// Якщо число парне, <br />// То друкуємо його <br />$і+ +; // збільшуємо лічильник на одиницю <br />}<br />?&gt;</p>
<p>У третє вираз конструкції for можна записувати через кому відразу кілька найпростіших команд. Наприклад, якщо ми хочемо просто вивести всі цифри, то програму можна записати зовсім просто:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />for ($i = 0; $i &lt;10; print $i, $i + +) <br />/ * Якщо блок_виконання не містить команд <br />або містить тільки одну команду, <br />фігурні дужки, в які він укладений, <br />можна опускати * / <br />?&gt;</p>
<h3 align="center">foreach</h3>
<p>Ще одна корисна конструкція. Вона з'явилася тільки в PHP4 і призначена виключно для роботи з масивами.</p>
<p style="margin-left:14.2pt;"><strong>Синтаксис:</strong> <br />foreach ($array as $value) {блок_виконання} <br />або <br />foreach ($array as $key =&gt; $value) <br />{Блок_виконання}</p>
<p>У першому випадку формується цикл по всіх елементах масиву, заданого змінною $array. На кожному кроці циклу значення поточного елемента масиву записується в змінну $value, і внутрішній лічильник масиву пересувається на одиницю (так що на наступному кроці буде записано наступний елемент масиву). Усередині блоку_виконання значення поточного елемента масиву може бути отримано за допомогою змінної $value. Виконання блоку_виконання відбувається стільки разів, скільки елементів в масиві $array.</p>
<p>Друга форма запису на додаток до перерахованого вище на кожному кроці циклу записує ключ поточного елемента масиву в змінну $key, яку теж можна використовувати в блоці_виконання.</p>
<p><strong>Приклад 14.</strong> Оператор foreach</p>
<p>Коли foreach починає виконання, внутрішній покажчик масиву автоматично встановлюється на перший елемент.</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />$Names = array ("Іван", "Петро", "Семен"); <br />foreach ($Names as $ val) { <br />echo "Привіт, $val &lt;br&gt;"; <br />// Виведе всім вітання <br />} <br />foreach ($Names as $k =&gt; $val) { <br />// Крім привітання, <br />// Виведемо номера в списку, тобто ключі <br />echo "Привіт, $val! <br />Ти в списку під номером $k &lt;br&gt; "; <br />} <br />?&gt; <br /> </p>
<h3 align="center">Оператори передачі управління</h3>
<p>Іноді потрібно негайно завершити роботу циклу або окремої його ітерації. Для цього використовують оператори break та continue.</p>
<h3 align="center">Break</h3>
<p style="margin-left:14.2pt;"><strong>Приклад 15.</strong> Оператор break</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />$I = 1; <br />while($ i) { <br />$N = rand (1,10); <br />// Генеруємо довільне число <br />// Від 1 до 10 <br />echo "$I: $N "; <br />// Виводимо номер ітерації і <br />// Згенероване число <br />if ($N == 5) break; <br />/* Якщо було створене число 5, <br />то припиняємо роботу циклу. У цьому випадку <br />все, що знаходиться після цього рядка <br />всередині циклу, не буде виконана * / <br />echo "Цикл працює &lt;br&gt;"; <br />$I++; <br />} <br />echo "&lt;br&gt; Число ітерацій циклу $ i"; ?&gt;</p>
<p style="margin-left:14.2pt;">Результатом роботи цього скрипта буде приблизно наступне: <br />1:7 Цикл працює<br />2:2 Цикл працює<br />3:5<br />Число ітерацій циклу 3<br />Трохи змінимо наш скрипт:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />$i = 1; <br />while ($i) { <br />$n = rand (1,10); <br />// Генеруємо довільне число <br />// Від 1 до 10 <br />switch ($n) { <br />case 5: <br />echo "&lt;font color=blue&gt; <br />Вихід з switch (n = $n) "; <br />break 1; <br />// Припиняємо роботу switch <br />// (Один break циклу) <br />case 10: <br />echo "&lt;font color=red&gt; <br />Вихід з switch і <br />while (n = $n) "; <br />break 2; <br />// Припиняємо роботу switch і while <br />// (Два break циклів) <br />default: <br />echo "switch працює (n = $n),"; <br />} <br />echo "while працює - крок $i &lt;br&gt;"; <br />$i+ +; <br />} <br />echo "&lt;br&gt; Число ітерацій циклу $i"; <br />?&gt;</p>
<h3 align="center">continue</h3>
<p>Іноді потрібно не повністю припинити роботу циклу, а тільки почати його нову ітерацію. Оператор continue дозволяє пропустити подальші інструкції з блоку_виконання будь-якого циклу і продовжити виконання з нового кола. continue можна використовувати з числовим аргументом, який вказує, скільки ітерацій циклу повинні завершити роботу.</p>
<p>Замінимо в прикладі попереднього параграфа оператор break на continue. Крім того, обмежимо кількість кроків циклу трьома.</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />$i = 1; <br />while ($i &lt;= 4) { <br />$n = rand (1,10); <br />// Генеруємо довільне число <br />// Від 1 до 10 <br />echo "$i: $n"; <br />// Виводимо номер ітерації і <br />// Згенероване число <br />if ($ n == 5) { <br />echo "Нова ітерація &lt;br&gt;"; <br />continue; <br /><br />/* Якщо було створене число 5, <br />то починаємо нову ітерацію циклу, <br />$і не збільшується */ <br />} <br />echo "Цикл працює &lt;br&gt;"; <br />$і+ +; <br />} <br />$і--; <br />echo "&lt;br&gt; Число ітерацій циклу $ i"; <br />?&gt;</p>
<p style="margin-left:14.2pt;">Результатом роботи цього скрипта буде <br />1:10 Цикл працює <br />2:5 Нова ітерація <br />2:1 Цикл працює <br />3:1 Цикл працює <br />Число ітерацій циклу 4</p>
<p>Зауважимо, що після виконання оператора continue робота циклу не закінчується. У прикладі лічильник циклу не змінюється в разі отримання числа 5, оскільки він перебуває після оператора continue. Фактично за допомогою continue ми намагаємося уникнути ситуації, коли буде створене число 5. Тому можна було просто написати, замінивши оператор continue на перевірку істинності висловлювання:</p>
<p>&lt;? Php <br />$I = 1; <br />while ($I &lt;4) { <br />$N = rand (1,10); <br />// Генеруємо довільне число <br />// Від 1 до 10 <br />if ($N! == 5) { <br />echo "$ i: $ n &lt;br&gt;"; <br />// Виводимо номер ітерації <br />// І згенероване число <br />$I + +; <br />} <br />} <br />?&gt;</p>
<p>У PHP існує одна особливість використання оператора continue - в конструкціях switch він працює так само, як і break. Якщо switch знаходиться всередині циклу й треба почати нову ітерацію циклу, слід використовувати continue 2.</p>
<p> </p>
<h3 align="center">Оператори включення</h3>
<p align="center"><strong>include</strong></p>
<p>Оператор include дозволяє включати код, що міститься у вказаному файлі, і виконувати його стільки разів, скільки програма зустрічає цей оператор. Включення може здійснюватися будь-яким з перерахованих способів:</p>
<p align="center">include 'ім'я_файлу'; <br />include $file_name; <br />include ("ім'я_файлу");</p>
<p><strong>Приклад 16</strong>. Нехай у файлі params.inc у нас зберігається набір якихось параметрів і функцій. Кожного разу, коли нам потрібно буде використовувати ці параметри (функції), ми будемо додавати до тексту нашої основної програми команду include 'params.inc'.</p>
<p style="margin-left:14.2pt;"><strong>Приклад 16.</strong> Використання оператора включення include</p>
<p style="margin-left:14.2pt;">params.inc <br /><br />&lt;? Php <br />$User = "Вася"; <br />$Today = date ("d.m.y"); <br />/ * Функція date () повертає дату <br />і час (тут - дату в форматі <br />день.місяць.рік) * / <br />?&gt; <br /><br />include.php<br /><br /> &lt;? Php <br />include ("params.inc"); <br />/* Змінні $User і $Today задані у файлі <br />params.inc. Тут ми теж можемо ними <br />користуватися завдяки команді <br />include ("params.inc") * / <br /><br />echo "Привіт, $User! &lt;br&gt;"; <br />// Виведе "Привіт, Вася!" <br />echo "Сьогодні $Today"; <br />// Виведе, наприклад, "Сьогодні 24.01.11"<br />?&gt;</p>
<p>Зауважимо, що використання оператора include еквівалентно простий вставці змістовної частини файлу params.inc в код програми include.php. Справа в тому, що в момент вставки файлу відбувається перемикання з режиму обробки PHP в режим HTML. Тому код всередині файлу, який потрібно обробити як PHP-скрипт, повинен бути укладений у відповідні теги.</p>
<p align="center"><strong>Пошук файлу для вставки відбувається за такими правилами.</strong></p>
<ol><li>Спочатку ведеться пошук файлу в include_path поточної робочої директорії.</li>
<li>Якщо файл не знайдений, то пошук виконується в include_path директорії поточного скрипта.</li>
<li>Параметр include_path, визначається у файлі налаштувань PHP, задає імена директорій, в яких потрібно шукати файли, що включаються.</li>
</ol><p>Наприклад, ваш include_path це поточна робоча директорія - / www /. В основний файл include.php ви включаєте файл my_dir / a.php, який у свою чергу включає b.php. Тоді парсер насамперед шукає файл b.php в директорії / www /, і якщо такого немає, то в директорії / www / my_dir /.</p>
<p>Якщо файл включений з допомогою include, то код що міститься в ньому успадковує область видимості змінних. Будь-які змінні включеного файлу будуть доступні в файлі з цього рядка і далі. Відповідно, якщо include з'являється всередині функції файлу, який викликає, то код, що міститься в включеному файлі, буде вести себе так, як ніби він був визначений всередині функції. Таким чином, він успадкує область видимості цієї функції. Хоча ми і не знайомилися ще з поняттям функції, все ж наводимо тут ці відомості в розрахунку на інтуїтивне його розуміння.</p>
<p style="margin-left:14.2pt;"><strong>Приклад 17.</strong> Область видимості при використанні include .Нехай файл для вставки params.inc залишиться таким же, а include.php буде наступним:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />function Footer () { <br />// Оголошуємо функцію з ім'ям Footer <br />include ("params.inc"); <br />/* Включаємо файл params.inc. <br />Тепер його змінними можна користуватися, <br />але тільки всередині функції */ <br />$str = "Сьогодні: $today &lt;br&gt;"; <br />$str .= "&lt;a <br />href = 'mailto: <a href="mailto:help@intuit.ru">help@intuit.ru</a>'&gt; Сторінку <br />створив $user "; <br />echo "$str"; <br />} <br />Footer(); <br />// Викликаємо функцію Footer (). Отримаємо: <br />// Сьогодні: 08.07.05 <br />// Сторінку створив Вася <br /><br />echo "$user, $today"; <br />// Нічого не виведе, так як <br />// Ці змінні видно тільки <br />// Всередині функції<br /> ?&gt; </p>
<p>Крім локальних файлів, за допомогою include можна включати і зовнішні файли, вказуючи їх url-адреси. Дана можливість контролюється директивою url_fopen_wrappers у файлі налаштувань PHP і за замовчуванням, як правило, включена. Але у версіях PHP для Windows до PHP 4.3.0 ця можливість не підтримується зовсім, незалежно від url_fopen_wrappers.</p>
<p style="margin-left:14.2pt;">include () - це спеціальна мовна конструкція, тому при використанні всередині блоків її потрібно укладати у фігурні дужки.</p>
<p style="margin-left:14.2pt;"><strong>Приклад 18.</strong> Використання include ()</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />/* Це невірний запис. Отримаємо помилку. <br />Ми ж вставляємо не одну команду, <br />а декілька, вони тільки записані <br />в іншому файлі */ <br />if ($condition) include ("first.php"); <br />else include ("second.php"); <br />// А ось так правильно. <br />if ($ condition) {include ("first.php");} <br />else {include ("second.php");} <br />?&gt; <br /> </p>
<p>При використанні include можливо два види помилок - помилка вставки (наприклад, не можна знайти вказаний файл, невірно написана сама команда вставки тощо) або помилка виконання (якщо помилка міститься у файлі, що вставляється). У будь-якому випадку при помилці в команді include виконання скрипта не завершується.</p>
<h3 align="center">require</h3>
<p>Цей оператор діє приблизно так само, як і #include в C+ +. Все, що ми говорили про include, лише за деякими винятками, справедливо і для require. require також дозволяє включати в програму і виконувати який-небудь файл. Основна відмінність require і include полягає в тому, як вони реагують на виникнення помилки. Як вже говорилося, include видає попередження, і робота скрипта триває. Помилка в require викликає фатальну помилку роботи скрипта і припиняє його виконання.</p>
<p>Умовні оператори на require () не впливають. Якщо рядок, в якому з'являється цей оператор, не виконується, то жоден рядок коду з файлу теж не виконується. Цикли також не впливають на require (). Код, що міститься у файлі який є об'єктом циклу,вставляється але вставка відбувається тільки один раз.</p>
<p>У реалізаціях PHP до версії 4.0.2 використання require () означало, що інтерпретатор обов'язково спробує прочитати файл.</p>
<p>require, як і include, при використанні всередині умовних блоків потрібно укладати у фігурні дужки.</p>
<h3 align="center">Альтернативний синтаксис</h3>
<p>PHP пропонує альтернативний синтаксис для деяких своїх керуючих структур, а саме для if, while, for, foreach і switch. У кожному разі відкриваючу фігурну дужку потрібно замінити на двокрапку (:), а закриваючу - на endif;, endwhile, і т.д. відповідно.</p>
<p style="margin-left:14.2pt;">Наприклад, синтаксис оператора if можна записати таким чином: <br />if (вираз): блок_виконання endif;</p>
<p>Сенс залишається тим же: якщо умова, що записана в круглих дужках оператора if, виявилась істиною, буде виконуватися весь код, від двокрапки ":" до команди endif;. Використання такого синтаксису корисно при встроюванні php в html-код.</p>
<p><strong>Приклад 19.</strong> Використання альтернативного синтаксису</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />$ Names = array ("Іван", "Петро", "Семен"); <br />if ($Names [0] == "Іван"): <br />?&gt; <br />Привіт, Ваня! <br />&lt;? Php <br />endif;<br />?&gt;</p>
<p>Якщо використовуються конструкції else і elseif, то також можна задіяти альтернативний синтаксис:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />$a = 1; <br />if ($a == 5): <br />print "a дорівнює 5"; <br />print "..."; <br />elseif ($ a == 6): <br />print "a дорівнює 6"; <br />print "!!!"; <br />else: <br />print "a не дорівнює ні 5, ні 6"; <br />endif; <br />?&gt;</p>
<h3 align="center">Функції користувача</h3>
<p>Для чого потрібні функції? Щоб відповісти на це питання, потрібно зрозуміти, що взагалі являють собою функції. У програмуванні, як і в математиці, функція є відображення безлічі її аргументів на безліч її значень. Тобто функція для кожного набору значень аргументу повертає якісь значення, що є результатом її роботи. Навіщо потрібні функції, спробуємо пояснити на прикладі. Класичний приклад функції у програмуванні - це функція, що обчислює значення факторіала числа. Тобто ми задаємо їй число, а вона повертає нам його факторіал. При цьому не потрібно для кожного числа, факторіал якого ми хочемо отримати, повторювати один і той самий код - досить просто викликати функцію з аргументом, рівним цьому числу.</p>
<p align="center"><strong>Функція обчислення факторіала натурального числа</strong></p>
<p>&lt;? Php <br />function fact ($n) { <br />if ($n == 0) return 1; <br />else return $fact = $ n * fact ($ n-1); <br />} <br />echo fact (3); <br />// Можна було б написати echo (3 * 2); <br />// Але якщо число велике, <br />echo fact (50); <br />// То зручніше користуватися функцією, <br />// Ніж писати echo (50 * 49 * 48 *...* 3 * 2); <br />?&gt;</p>
<p>Таким чином, коли ми здійснюємо дії, в яких простежується залежність від будь-яких даних, і при цьому нам знадобиться виконувати такі ж дії, але з іншими вихідними даними, зручно використовувати механізм функцій - оформити блок дій у вигляді тіла функції, а змінні дані - як її параметр.</p>
<p>Подивимося, як у загальному вигляді виглядає оголошення функції. Функція може бути визначена за допомогою наступного синтаксису:</p>
<p style="margin-left:14.2pt;">function Імя_функціі (параметр1, параметр2, ... параметрN) { <br />Блок_дій <br />return "значення повертається функцією"; <br />}</p>
<p>Якщо прямо так написати в php-програмі, то працювати нічого не буде. По-перше, Імя_функції і імена параметрів функції (параметр1, параметр2 і т.д.) повинні відповідати правилам найменування в PHP (і українських символів в них краще не використовувати). Імена функцій нечутливі до регістру. По-друге, параметри функції - це змінні мови, тому перед назвою кожної з них повинен стояти знак $. Ніяких крапок ставити в списку параметрів не можна. По-третє, замість слів блок_дій в тілі функції повинен знаходитися будь-який правильний PHP-код (не обов'язково залежати від параметрів). І нарешті, після ключового слова return має йти коректний php-вираз (що-небудь, що має значення). Крім того, у функції може і не бути параметрів, як і значення, що повертається. Приклад правильного оголошення функції - функція обчислення факторіала, наведена вище.</p>
<p>Як відбувається виклик функції? Вказується ім'я функції і в круглих дужках список значень її параметрів, якщо такі є:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />Імя_функції ("значення_для_параметра1", <br />"Значення_для_параметра2 ",...); <br />// Приклад виклику функції - виклик функції <br />// Обчислення факторіала наведено вище, <br />// Там для обчислення факторіала числа 3 <br />// Ми писали: fact (3); <br />// Де fact - ім'я викликається функції, <br />// А 3 - значення її параметра з ім'ям $ n <br />?&gt;</p>
<p>Коли можна викликати функцію? Функцію можна викликати після її визначення, тобто в будь-якому рядку програми нижче блоку function f_name (){...}. У PHP3 це було дійсно так. Але вже в PHP4 такої вимоги немає. Вся справа в тому, як інтерпретатор обробляє одержуваний код. Єдиний виняток становлять функції, які визначаються умовно (всередині умовних операторів або інших функцій). Коли функція визначається таким чином, її визначення повинно передувати її виклику.</p>
<p><strong>Приклад 20.</strong> Визначення функції всередині умовного оператора</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />$Make = true; <br />/* Тут не можна викликати Make_event (); <br />тому що вона ще не існує, але можна <br />викликати Save_info () * / <br /><br />Save_info ("Вася", "Іванов", <br />"Я вибрав курс по PHP"); <br /><br />if ($Make) { <br />// Визначення функції Make_event () <br />function Make_event () { <br />echo "&lt;p&gt; Хочу вивчати Python &lt;br&gt;"; <br />} <br />} <br />// Тепер можна викликати Make_event () <br />Make_event (); <br />// Визначення функції Save_info <br />function Save_info ($first, $last, $message) { <br />echo "&lt;br&gt; $ message &lt;br&gt;"; <br />echo "Ім'я:". $first. "". $last. "&lt;br&gt;"; <br />} <br />Save_info ("Федя", "Федоров", <br />"А я вибрав Lisp"); <br />// Save_info можна викликати і тут <br />?&gt; </p>
<p>Якщо функція одного разу визначена в програмі, то перевизначити або видалити її пізніше не можна. Незважаючи на те, що імена функцій нечутливі до регістру, краще викликати функцію з того ж імені, яким вона була задана у визначенні.</p>
<p><strong>Приклад 21.</strong> Визначення функції усередині функції</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />/* Не можна зберегти дані, тобто викликати <br />функцію DataSave () до того, як виконана <br />перевірка їх правильності, тобто викликана <br />функція DataCheck () */ <br /><br />DataCheck (); <br />DataSave (); <br /><br />function DataCheck () { <br />// Перевірка правильності даних <br />function DataSave () { <br />// Зберігаємо дані <br />} <br />} <br />?&gt;</p>
<p style="margin-left:14.2pt;">Розглянемо докладніше аргументи функцій, їх призначення та використання.</p>
<h3 align="center">Аргументи функцій</h3>
<p>У кожній функції може бути список аргументів. За допомогою цих аргументів у функцію передається різна інформація (наприклад, значення числа, факторіал якого треба підрахувати). Кожен аргумент являє собою змінну або константу.</p>
<p>За допомогою аргументів дані у функцію можна передавати трьома різними способами. Це передача аргументів значенням (використовується за замовчуванням), по посиланню й завдання значення аргументів за замовчуванням. Розглянемо ці способи докладніше.</p>
<p>Коли аргумент передається у функцію за значенням, зміна значення аргументу всередині функції не впливає на його значення поза функцією. Щоб дозволити функції змінювати аргументи, їх потрібно передавати по посиланню. Для цього у визначенні функції перед ім'ям аргументу слід написати знак амперсанд «&amp;».</p>
<p><strong>Приклад 22.</strong> Передача аргументів за посиланням</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />// Напишемо функцію, яка б додавала <br />// До рядка слово checked <br />function add_label (&amp; $data_str) { <br />$data_str .= "checked"; <br />} <br />$str = "&lt;input type = radio name = article"; <br />// Нехай є такий рядок <br />echo $str. "&gt; &lt;br&gt;"; <br />// Виведе елемент форми - <br />// Не вибрану радіо кнопку <br />add_label ($str); <br />// Викличемо функцію <br />echo $ str. "&gt; &lt;br&gt;"; <br />// Це виведе вже вибрану <br />// Радіо кнопку <br />?&gt;</p>
<p>У функції можна визначати значення аргументів, які використовуються за замовчуванням. Значення за замовчанням має бути константним виразом, а не змінною і не представником класу або викликом іншої функції.</p>
<p>У нас є функція, яка створює інформаційне повідомлення, підпис до якого змінюється в залежності від значення переданого їй параметра. Якщо значення параметра не задано, то використовується підпис "Оргкомітет".</p>
<p><strong>Приклад 23.</strong> Значення аргументів за замовчуванням</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />function Message ($ sign = "Оргкомітет.") { <br />// Тут параметр sign має за замовчуванням значення "Оргкомітет" <br />echo "Наступне зібрання відбудеться завтра. &lt;br&gt;"; <br />echo $sign. "&lt;br&gt;"; <br />} <br />Message (); <br />// Викликаємо функцію без параметра. <br />// У цьому випадку підпис - це Оргкомітет <br />Message ("З повагою, Вася"); <br />// У цьому випадку підпис <br />// Буде "З повагою, Вася." <br />?&gt; <br /> </p>
<p><strong><em>Результатом роботи цього скрипта буде:</em></strong><br />Наступне зібрання відбудеться завтра. <br />Oргкомітет. <br />Наступне зібрання відбудеться завтра. <br />З повагою, Вася.</p>
<p>Якщо у функції декілька параметрів, то ті аргументи, для яких задаються значення за замовчуванням, повинні бути записані після всіх інших аргументів у визначенні функції. В іншому випадку з'явиться помилка, якщо ці аргументи будуть опущені при виклику функції.</p>
<p>Наприклад, ми хочемо внести опис статті в каталог. Користувач повинен ввести такі характеристики статті, як її назва, автор та короткий опис. Якщо користувач не вводить ім'я автора статті, вважаємо, що це Іванов Іван.</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />function Add_article ($title, $description, <br />$author = "Іванов Іван") { <br />echo "Заносимо в каталог статтю: $title,"; <br />echo "автор $author"; <br />echo "&lt;br&gt; Короткий опис:"; <br />echo "$description &lt;hr&gt;"; <br />} <br />Add_article ("Інформатика і ми", <br />"Це стаття про інформатику ...", <br />"Петров Петро"); <br />Add_article ("Хто такі хакери", <br />"Це стаття про хакерів ..."); <br />?&gt;</p>
<p style="margin-left:14.2pt;">У результаті роботи скрипта одержимо наступне <br />Заносимо в каталог статтю: Інформатика і ми, <br />автор Петров Петро. <br />Короткий опис: <br />Це стаття про інформатику ...</p>
<p style="margin-left:14.2pt;">Заносимо в каталог статтю: Хто такі хакери, <br />автор Іванов Іван. <br />Короткий опис: <br />Це стаття про хакерів ...</p>
<p style="margin-left:14.2pt;">Якщо ж ми напишемо ось так:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />function Add_article ($author = "Іванов Іван", <br />$title, $description) { <br />// ... Дії як у попередньому прикладі <br />} <br />Add_article ("Хто такі хакери", <br />"Це стаття про хакерів ..."); <br />?&gt;</p>
<p style="margin-left:14.2pt;">То в результаті отримаємо: <br />Warning: Missing argument 3 for <br />add_article () in <br />c: \ users \ nina \ tasks \ func \ def_bad.php <br />on line 2</p>
<h3 align="center">Списки аргументів змінної довжини</h3>
<p>В PHP4 можна створювати функції зі змінним числом аргументів. Тобто ми створюємо функцію, не знаючи заздалегідь, зі скількома аргументами її викличуть. Для написання такої функції ніякого спеціального синтаксису не потрібно. Все робиться за допомогою вбудованих функцій func_num_args (), func_get_arg (), func_get_args ().</p>
<p>Функція func_num_args () повертає число аргументів, переданих в поточну функцію. Ця функція може використовуватися тільки усередині тіла функції користувача. Якщо вона з'явиться поза функцією, то інтерпретатор видасть попередження.</p>
<p style="margin-left:14.2pt;"><strong>Приклад 24.</strong> Використання функції func_num_args ()</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />function DataCheck () { <br />$N = func_num_args (); <br />echo "Кількість аргументів функції $N"; <br />} <br />DataCheck (); <br />// Виведе рядок <br />// "Число аргументів функції 0" <br />DataCheck (1,2,3); <br />// Виведе рядок <br />// "Число аргументів функції 3" <br />?&gt; <br /> </p>
<p>Функція func_get_arg (ціле номер_аргумента) повертає аргумент зі списку переданих у функцію аргументів, порядковий номер якого заданий параметром номер_аргумента. Аргументи функції починаються з нуля. Як і func_num_args (), ця функція може використовуватися тільки усередині тіла якої-небудь функції.</p>
<p>Номер_аргумента не може перевищувати число аргументів, переданих у функцію. Інакше буде згенероване попередження, і функція func_get_arg () поверне False.</p>
<p>Створимо функцію для перевірки типу даних її аргументів. Вважаємо, що перевірка пройшла успішно, якщо перший аргумент функції - ціле число, другий - рядок.</p>
<p style="margin-left:14.2pt;"><strong>Приклад 25.</strong> Функція для перевірки типу даних, її аргументів</p>
<p style="margin-left:14.2pt;">&lt;? <br />function DataCheck () { <br />$Check = true; <br />$n = func_num_args (); <br />// Число аргументів, <br />// Переданих у функцію <br />/* Перевіряємо, чи є першим <br />переданий аргумент цілим числом */ <br />if ($ n&gt; = 1) if (! is_int (func_get_arg (0))) <br />$Check = false; <br />/* Перевіряємо, чи є другий <br />переданий аргумент рядком */ <br />if ($n&gt; = 2) <br />if (!is_string (func_get_arg (1))) <br />$Check = false; <br />return $Check; <br />} <br /><br />if (DataCheck (123, "text")) <br />echo "Перевірка пройшла успішно &lt;br&gt;"; <br />else echo "Дані не задовольняють <br />умовам &lt;br&gt; "; <br />if (DataCheck (324)) <br />echo "Перевірка пройшла успішно &lt;br&gt;"; <br />else echo "Дані не задовольняють умовам &lt;br&gt;"; <br />?&gt; </p>
<p style="margin-left:14.2pt;"><em>Результатом роботи буде наступне.</em> <br />Перевірка пройшла успішно <br />Перевірка пройшла успішно</p>
<p>Функція func_get_args () повертає масив, що складається зі списку аргументів, переданих функції. Кожен елемент масиву відповідає аргументу, переданому функції. Якщо функція використовується поза тілом функції, то генерується попередження.</p>
<p>Перепишемо попередній приклад, використовуючи цю функцію. Будемо перевіряти, чи є цілим числом кожен парний аргумент, переданий функції:</p>
<p style="margin-left:14.2pt;">&lt;? <br />function DataCheck () { <br />$Check = true; <br />$N = func_num_args (); <br />// Число аргументів, <br />// Переданих у функцію <br /><br />$Args = func_get_args (); <br />// Масив аргументів функції <br />for ($i = 0; $i &lt;$ n; $i + +) { <br />$V = $ args [$ i]; <br />if($ i% 2 == 0) { <br />if(!is_int ($V)) $ check = false; <br />// Перевіряємо, <br />// Чи є парний аргумент цілим <br />} <br />} <br />return $ check; <br />} <br />if (DataCheck (array ("text", 324))) <br />echo "Перевірка пройшла успішно &lt;br&gt;"; <br />else echo "Дані не задовольняють <br />умовам &lt;br&gt; "; <br />?&gt;</p>
<p>Як бачимо, комбінації функцій func_num_args (), func_get_arg () і func_get_args () використовується для того, щоб функції могли мати змінний список аргументів. Ці функції були додані тільки в PHP 4. У PHP3 для того, щоб домогтися подібного ефекту, можна використовувати в якості аргументу функції масив. Наприклад, ось так можна написати скрипт, який перевіряє, чи є кожен непарний параметр функції цілим числом:</p>
<p style="margin-left:14.2pt;">&lt;? <br />function DataCheck ($params) { <br />$Check = true; <br />$N = count ($ params); <br />// Число аргументів, <br />// Переданих у функцію <br /><br />for ($i = 0; $i &lt;$ n; $i + +) { <br />$V = $params [$ i]; <br />if ($ i% 2! == 0) { <br />// Перевіряємо, чи є непарний <br />// Аргумент цілим <br />if (! is_int ($V)) $Check = false; <br />} <br />} <br />return $Check; <br />} <br />if (DataCheck (array ("text", 324))) <br />echo "Перевірка пройшла успішно &lt;br&gt;"; <br />else echo "Дані не задовольняють умовам &lt;br&gt;"; <br />?&gt;</p>
<h3 align="center">Використання змінних всередині функції</h3>
<p align="center"><strong>Глобальні змінні</strong></p>
<p>Щоб використовувати всередині функції змінні, задані поза нею, ці змінні потрібно оголосити як глобальні. Для цього в тілі функції слід перерахувати їх імена після ключового слова global:</p>
<p>global $ var1, $ var2;</p>
<p><strong>Приклад 26.</strong> Глобальні змінні</p>
<p style="margin-left:14.2pt;">&lt;? <br />$a = 1; <br />function Test_g () { <br />global $a; <br />$a = $a * 2; <br />echo 'в результаті роботи функції $ a =', $a; <br />} <br />echo 'поза функції $a =', $a, ','; <br />Test_g (); <br />echo "&lt;br&gt;"; <br />echo 'поза функції $a =', $a, ','; <br />Test_g (); ?&gt;</p>
<p style="margin-left:14.2pt;">У результаті роботи цього скрипта одержимо: <br />поза функції $a = 1, в результаті роботи <br />функції $a = 2 <br />поза функції $a = 2, в результаті роботи <br />функції $a = 4</p>
<p>Коли змінна оголошується як глобальна, фактично створюється посилання на глобальну змінну. Тому такий запис еквівалентний наступному (масив $GLOBALS містить всі змінні, глобальні щодо поточної області видимості):</p>
<p style="margin-left:14.2pt;">$Var1 = &amp; $GLOBALS ["var1"]; <br />$Var2 = &amp; $GLOBALS ["var2"];</p>
<p>Це означає що видалення змінної $var1 не видаляє глобальної змінної $GLOBALS ["var1"].</p>
<h3 align="center">Статичні змінні</h3>
<p>Щоб використовувати змінні тільки всередині функції, при цьому зберігаючи їх значення і після виходу з функції, потрібно оголосити ці змінні як статичні. Статичні змінні видно тільки всередині функції але вони не втрачають свого значення, якщо виконання програми виходить за межі функції. Оголошення таких змінних проводиться за допомогою ключового слова static:</p>
<p>static $var1, $var2;</p>
<p>Статичній змінній може бути присвоєно будь-яке значення, але не посилання.</p>
<p><strong>Приклад 27.</strong> Використання статичної змінної</p>
<p style="margin-left:14.2pt;">&lt;? <br />function Test_s () { <br />static $a = 1; <br />// Можна присвоювати вираз або посилання <br />$a = $a * 2; <br />echo $a; <br />} <br />Test_s (); // виведе 2 <br />echo $a; // нічого не виведе, так як <br />// $a доступна тільки <br />// Всередині функції <br />Test_s (); // всередині функції $a = 2, тому <br />// Результатом роботи функції <br />// Буде число 4 <br />?&gt;</p>
<h3 align="center">Значення, що повертаються</h3>
<p>Всі функції, наведені вище в якості прикладів, виконували будь-які дії. Окрім подібних дій, будь-яка функція може повертати як результат своєї роботи якесь значення. Це робиться за допомогою return. Значення, що повертається може бути будь-якого типу, включаючи списки і об'єкти. Коли інтерпретатор зустрічає команду return у тілі функції, він негайно припиняє її виконання і переходить на той рядок, з якої була викликана функція.</p>
<p>Наприклад, складемо функцію, яка повертає вік людини. Якщо людина не померла, то вік вважається відносно поточного року.</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />/* Якщо другий параметр передається він сприймається <br />як true, то він розглядається як <br />дата смерті, */ <br /><br />function Age ($birth, $is_dead) { <br />if ($is_dead) return $is_dead-$ birth; <br />else return date ("Y") - $birth; <br />} <br />echo Age (1971, false); // для 2009 року виведе 38 <br />echo Age (1971, 2001); // виведе 30 <br />?&gt;</p>
<p>У цьому прикладі можна було і не використовувати функцію return, а просто замінити її функцією виведення echo. Проте якщо ми все-таки робимо так, що функція повертає якесь значення (у даному випадку вік людини), то в програмі ми можемо присвоїти будь-якій змінній значення цієї функції:</p>
<p>$An_age = Age (1981, 2004);</p>
<p>У результаті роботи функції може бути повернуто лише одне значення. Кілька значень можна отримати, якщо повертати список значень (одновимірний масив). Припустимо, ми хочемо отримати повний вік людини з точністю до дня.</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />function Full_age ($ b_day, $ b_month, $ b_year) <br />{ <br />$y = date ("Y"); <br />$m = intval (date ("m")); <br />$d = intval (date ("d")); <br />$B_month = intval($ b_month); <br />$B_day = intval($ b_day); <br />$B_year = intval($ b_year); <br /><br />$day = ($b_day&gt; $d? 30 - $b_day + $d: $d - $b_day); <br />$tmpMonth = ($b_day&gt; $d? -1: 0); <br />$month = ($b_month&gt; $m + $tmpMonth? 12 - $ b_month + <br />$tmpMonth + $m: $m + $tmpMonth - $b_month); <br />$tmpYear = ($b_month&gt; $m + $tmpMonth? -1: 0); <br />if ($b_year&gt; $y + $tmpYear) <br />{ <br />$year = 0; $month = 0;$ day = 0; <br />} <br />else <br />{ <br />$year = $y + $tmpYear - $b_year; <br />} <br />return array ($day, $month, $year); <br />} <br />$Age = Full_age ("29", "06", "1986"); <br />echo "Вам $age [2] років, $ age[1] місяців і $age [0] днів"; <br />?&gt;</p>
<p>Коли функція повертає кілька значень для їх обробки в програмі, зручно використовувати мовну конструкцію list (), яка дозволяє однією дією присвоїти значення одразу кільком змінним. Наприклад, у попередньому прикладі, залишивши без зміни функцію, обробити повернене значення можна так:</p>
<p style="margin-left:14.2pt;">&lt;? <br />// Виклик функції Full_age () <br />list ($ay, $ month, $ year) = Full_age ("07","08", "1974"); <br />echo "Вам $year років, $month місяців і $day днів "; <br />?&gt;</p>
<p>Взагалі конструкцію list () можна використовувати для присвоєння змінним значень елементів будь-якого масиву.</p>
<p><strong>Приклад 28.</strong> Використання list ()</p>
<p style="margin-left:14.2pt;">&lt;? <br />$Arr = array ("first", "second"); <br />list ($ a, $ b) = $Arr; <br />// Змінній $a присвоюється перше <br />// Значення масиву, $b - друге <br />echo $a, "", $b; <br />// Виведе рядок «first second» <br />?&gt;</p>
<h3 align="center">Повернення посилання</h3>
<p>У результаті своєї роботи функція також може повертати посилання на будь-яку змінну. Це може стати в нагоді, якщо потрібно використовувати функцію для того, щоб визначити, якій змінній повинно бути присвоєно посилання. Щоб отримати з функції посилання, потрібно при оголошенні перед її ім'ям написати знак амперсанду (&amp;) і щоразу при виклику функції перед її ім'ям теж писати амперсанд (&amp;). Зазвичай функція повертає посилання на будь-яку глобальну змінну (або її частину - посилання на елемент глобального масиву), посилання на статичну змінну (або її частину) або посилання на один з аргументів, якщо він був також переданий по посиланню.</p>
<p><strong>Приклад 29.</strong> Повернення посилання</p>
<p style="margin-left:14.2pt;">&lt;? <br />$а = 3; $ b = 2; <br />function &amp; ref ($par) { <br />global $a, $b; <br />if ($par% 2 == 0) return $b; <br />else return $a; <br />} <br />$var = &amp; ref (4); <br />echo $var, "і", $b, "&lt;br&gt;"; <br />// Виведе 2 і 2 <br />$b = 10; <br />echo $ var, "і", $ b, "&lt;br&gt;"; <br />// Виведе 10 і 10 ?&gt; <br /> </p>
<p>При використанні синтаксису посилань на змінну $var нашого прикладу не копіюється значення змінної $b повернутої функцією $ref, а створюється посилання на цю змінну. Тобто тепер змінні $var і $b ідентичні і будуть змінюватися одночасно.</p>
<h3 align="center">Змінні функції</h3>
<p>PHP підтримує концепцію змінних функцій. Це означає, що якщо ім'я змінної закінчується круглими дужками, то PHP шукає функцію з таким же ім'ям і намагається її виконати.</p>
<p><strong>Приклад 30.</strong> Використання змінних функцій</p>
<p style="margin-left:14.2pt;">&lt;? <br />/* Створимо дві прості функції: <br />Add_sign - додає підпис до рядка і <br />Show_text - виводить рядок тексту * / <br /><br />function Add_sign ($string, <br />$sign = "З повагою, Петро") { <br />echo $string. "". $sign; <br />} <br />function Show_text () { <br />echo "Відправити повідомлення поштою &lt;br&gt;"; <br />} <br />$Func = "Show_text"; <br />// Створюємо змінну зі значенням, <br />// Рівним імені функції Show_text <br />$Func (); <br />// Це викличе функцію Show_text <br />$Func = "Add_sign"; <br />// Створюємо змінну зі значенням, <br />// Рівним імені функції Add_sign <br />$Func ("Привіт всім &lt;br&gt;"); <br />// Це викличе функцію <br />// Add_sign з параметром "Привіт усім" <br />?&gt;</p>
<p>У цьому прикладі функція Show_text просто виводить рядок тексту. Здавалося навіщо для цього створювати окрему функцію, якщо існує спеціальна функція echo (). Справа в тому, що такі функції, як echo (), print (), unset (), include () і т.п. не можна використовувати в якості змінних функцій. Тобто якщо ми напишемо:</p>
<p style="margin-left:14.2pt;">&lt;? <br />$Func = "echo"; <br />$Func ("TEXT"); <br />?&gt; <br />то інтерпретатор виведе помилку: <br />Fatal error: Call to undefined function: <br />echo () in <br />c: \ users \ nina \ tasks \ func \ var_f.php on line 2</p>
<p>Тому для того, щоб використовувати будь-яку з перерахованих вище функцій як змінну функцію, потрібно створити власну функцію, що ми і зробили в попередньому прикладі.</p>
<h3 align="center">Символічні і жорсткі посилання</h3>
<p>Хоча в PHP немає такого поняття, як покажчик, все ж таки існує можливість створювати посилання на інші змінні. Існує два різновиди посилань: жорсткі і символічні (змінні) (перші часто називають просто посиланнями). Жорсткі посилання з'явилися в PHP версії 4 (в третій версії існували лише символічні посилання).</p>
<p><strong>Посилання в PHP</strong> - це засіб доступу до вмісту однієї змінної під різними іменами. Вони не схожі на покажчики мови Сі і не є псевдонімами таблиці символів. У PHP ім'я змінної і її вміст - це різні речі, тому один вміст може мати різні імена. Найближча аналогія - імена файлів Unix і медіа - імена змінних є елементами каталогів, а вміст змінних це самі файли. Посилання в PHP - аналог жорстких посилань (hardlinks) у файлових системах Unix.</p>
<h3 align="center">Жорсткі посилання в PHP</h3>
<p>Жорстке посилання представляє собою просто змінну, яка є синонімом іншої змінної. Багаторівневі посилання (тобто, посилання на посилання змінної, як це можна робити, наприклад, у Perl) не підтримуються. Так що не варто сприймати жорсткі посилання серйозніше, ніж синоніми.</p>
<p>Щоб створити жорстке посилання, потрібно використовувати оператор &amp; (амперсанд). Наприклад:</p>
<p style="margin-left:14.2pt;">$a = 10; <br />$b = &amp; $a; // тепер $b - те ж саме, що і $a <br />$b = 0; // насправді $a = 0 <br />echo "b = $b, a = $a"; / / Виводить: "b = 0, a = 0"</p>
<p>Посилатися можна не тільки на змінні, але й на елементи масиву (цим жорсткі посилання вигідно відрізняються від символічних). Наприклад:</p>
<p style="margin-left:14.2pt;">$a = array ('a' =&gt; 'aaa', 'b' =&gt; 'bbb'); <br />$b = &amp; $a ['b']; // тепер $b - те ж, що й елемент з індексом 'b' масиву <br />$b = 0; / / насправді $a ['b'] = 0; <br />echo $a ['b']; // Виводить 0</p>
<p>Втім, елемент масиву, для якого планується створити символічне посилання, може і не існувати. Як у наступному випадку:</p>
<p style="margin-left:14.2pt;">$a = array ('a' =&gt; 'aaa', 'b' =&gt; 'bbb'); <br />$b = &amp; $a ['c']; // тепер $b - те ж, що й елемент з індексом 'c' масиву <br />echo "Елемент з індексом 'c': (". $a ['c'].")";</p>
<p>В результаті виконання розглянутого скрипта, хоча посиланням $b і не було нічого присвоєно, в масиві $a створиться новий елемент з ключем c і значенням - порожній рядком (ми можемо це визначити за результатом роботи echo). Тобто, жорстке посилання на самому ділі не може посилатися на неіснуючий об'єкт, а якщо робиться така спроба, то об'єкт створюється.</p>
<p><strong>Примітка:</strong> Якщо прибрати рядок, в якій створюється жорстке посилання, то буде виведено повідомлення про те, що елемент з ключем c не визначено в масиві $а.</p>
<p>Жорсткі посилання зручно застосовувати при передачі параметрів для функції користувача і повернення значення з неї.</p>
<h3 align="center">Символічні посилання (змінні на змінні)</h3>
<p><strong>Символічне посилання</strong> - це всього лише рядкова змінна, що зберігає ім'я іншої змінної. Щоб дістатися до значення змінної, на яку посилається символічне посилання, необхідно застосувати додатковий знак $ перед ім'ям посилання. Розглянемо приклад:</p>
<p style="margin-left:14.2pt;">$A = 10; <br />$B = 20; <br />$C = 30; <br />$P = "А"; / / або $Р = "В" або $Р = "С" (присвоюємо $p ім'я іншої змінної) <br />echo $$Р; // виводить змінну, на яку посилається $Р, тобто $А <br />$$P = 100; / / присвоює $А значення 100</p>
<p>Ми бачимо, що для того, щоб використовувати звичайну рядкову змінну як посилання, потрібно перед нею поставити ще один символ $. Це говорить інтерпретатору, що треба взяти не значення самої $Р, а значення змінної, ім'я якої зберігається у змінній $Р.</p>
<p>Символічні посилання (змінні на змінні) використовуються досить рідко.</p>
<p> </p>
<h2 align="center">Жорсткі посилання і призначені для функцій користувача</h2>
<p> </p>
<h3 align="center">Передача значень за посиланням</h3>
<p>Ви можете передавати змінні в функцію користувача по посиланню, якщо ви хочете дозволити функції модифікувати свої аргументи. У такому випадку, функція користувача зможе змінювати аргументи. Синтаксис такий:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />function foo (&amp; $var) <br />{ <br />$var + +; <br />} <br /><br />$a = 5; <br />foo ($a); <br />// $a тут дорівнює 6 <br />?&gt;</p>
<p>Зауважте, що у виклику функції відсутній знак посилання - він є тільки у визначенні функції. Цього достатньо для коректної передачі аргументів за посиланням.</p>
<p>Ще один цікавий приклад:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />function funct (&amp; $string) <br />{ <br />$string .= 'а ця всередині.'; <br />} <br />$str = 'Цей рядок за межами функції,'; <br />funct ($str); <br />echo $ str; // Виведе 'Цей рядок за межами функції, а ця всередині.' <br />?&gt;</p>
<p>За посиланням можна передавати:</p>
<ul><li>Змінні, наприклад foo ($ a)</li>
<li>Оператор new, наприклад foo (new foobar ())</li>
<li>Лінки, які повертаються функцією, наприклад:</li>
</ul><p>&lt;? Php <br />function &amp; bar () <br />{ <br />$a = 5; <br />return $a; <br />} <br />foo (bar ()); <br />?&gt;</p>
<p>Будь-яке інше вираження не повинно передаватися по посиланню, так як результат не визначений. Наприклад, наступна передача за посиланням є неправильною:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />function bar () // Операція &amp; відсутня <br />{ <br />$a = 5; <br />return $a; <br />} <br />foo (bar ()); <br /><br />foo ($a = 5); // Вираз, а не змінна <br />foo (5); // Константа, а не змінна <br />?&gt;</p>
<h3 align="center">Повернення значень за посиланням</h3>
<p>Розглянемо ще одну можливість функцій користувача PHP - повернення посилань.</p>
<p>Повернення за посиланням використовується в тих випадках, коли ви хочете використовувати функцію для вибору змінної, з якою має бути пов'язана дане посилання. При поверненні за посиланням використовуйте такий синтаксис:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />function &amp; find_var ($param) <br />{ <br />/ * ... код ... * / <br />return $found_var; <br />} <br /><br />$foo = &amp; find_var ($ bar); <br />$foo-&gt; x = 2; <br />?&gt;</p>
<p>У цьому прикладі встановлюється властивість об'єкта, повернутого функцією find_var, а не його копії, як було б без використання посилань.</p>
<p>Ще один приклад повернення значень користувача функції за посиланням:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />$a= 100; <br />/* Далі йде функція, яка повертає посилання */ <br />function &amp; s () { <br />global $a; <br />// Повертаємо посилання на змінну $a <br />return $a; <br />} <br />// Надаємо посилання змінної $b <br />$b = &amp; s (); <br />$b = 0; <br />echo $a; // Виводить 0 <br />?&gt;</p>
<h3 align="center">Видалення посилань (скидання посилань)</h3>
<p>При видаленні посилання, просто розривається зв'язок імені та вмісту змінної. Це не означає, що вміст змінної буде зруйновано. Наприклад:</p>
<p style="margin-left:14.2pt;">&lt;? Php <br />$a = 1; <br />$b = &amp; $a; <br />unset ($a); <br />?&gt;</p>
<p style="margin-left:14.2pt;">Цей код не скине $b, а тільки $a.</p>
<p>І все ж, жорстке посилання - не абсолютно точний синонім об'єкта, на який він посилається. Справа в тому, що оператор Unset (), виконаний для жорсткого посилання, не видаляє об'єкт, на який він посилається, а всього лише розриває зв'язок між посиланням і об'єктом.</p>
<p>Отже, жорстке посилання і змінна (об'єкт), на яку він посилається, абсолютно рівноправні, але зміна однієї тягне зміну іншої. Оператор Unset () розриває зв'язок між об'єктом і посиланням, але об'єкт видаляеться тільки тоді, коли на нього ніхто вже не посилається.</p>
</div></div></div><div class="field field-name-field-tags field-type-taxonomy-term-reference field-label-above"><div class="field-label">Tags:&nbsp;</div><div class="field-items"><div class="field-item even" rel="dc:subject"><a href="/web4php" typeof="skos:Concept" property="rdfs:label skos:prefLabel" datatype="">WEB-програмування (4 курс PHP)</a></div></div></div>  </div>

  
  
</div>
                                
            </div>
        
        </div><!-- /#content -->
        
                
        <div class="clear"></div>
        
                
  </div>
        
  <div id="footer" >
        <div class="container">
          <div class="sixteen columns clearfix">
        
                <div class="one_third">
                  <div class="region region-footer-first">
    <div id="block-block-1" class="block block-block">

    
  
</div>
  </div>
                </div>
                
                <div class="one_third">
                                </div>
                
                <div class="one_third last">
                                </div>
        
                <div class="clear"></div>
                
                                
                <div class="clear"></div>
                
                
          </div>
        </div>
    </div>
    
</div> <!-- /#wrap -->  </body>
</html>
