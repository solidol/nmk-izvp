[Перелік усіх робіт](README.md)

# Лабораторна робота №13. Створення класів та екземплярів класів

## Мета роботи

Навчитися створювати класи та працювати з екземплярами класів

## Обладнання

Персональний комп'ютер. Пакет програм XAMPP. Текстовий редактор Sublime Text 3 або IDE NetBeans. Web-браузер Chrome, Firefox, Opera

## Хід роботи
1. Впевнитись, що пакет XAMPP встановлено та web-сервер Apache запущений
2. Перейти до каталогу `C:\xampp\htdocs\` та очистити його
3. Для створення класу в PHP використовується ключове слово class. У файлі index.php створимо новий клас, що представляє користувача: 
```php 
class User
	{
	}	
```
4. Щоб створити об'єкт класу User, застосовується ключове слово new:
```php
<?php
class User
    {
    }
$user = new User;
print_r($user);
?>   		
```
Збережемо файл

5. Модифікуємо index.php, додавши до класу User кілька властивостей та методів, які викликаються на екземплярі класу:   
```php
<?php
class User
{
    public $name, $age;
	function getInfo()
	{
		echo "Ім'я: $this->name; Вік: $this->age <br>";
	}
}
$user = new User; // Створення екземпляра класа User
// Отримуємо доступ до членів класу
$user->name = "Tom";
$user->age  = 30;
$user->getInfo();
print_r($user);
?>	
```
6. Іноді виникає необхідність виконати ініціалізацію об'єкта - присвоїти його властивостям початкові значення. Створимо клас Person, який містить дві властивості: ім'я людини і місто його проживання. Можна написати метод, який буде виконувати ініціалізацію об'єкта, наприклад `Init()`:
```php

<?php
class Person // Створюємо новий клас Person
{
    // Властивості
    var $name;
    var $city;
    // Ініціалізуючий метод
    function Init($name)
    {
        $this->name = $name;
        $this->city = "Київ";
    }
}
$object = new Person; // Створюємо об`єкт класу Person
$object->Init(); // Для ініціалізації об`єкту одразу викликаємо метод
?>
```
Для того, щоб PHP знав, що певний метод потрібно викликати автоматично при створенні об'єкта, йому потрібно дати ідентичне ім'я до назви класу. Метод, що ініціалізує об'єкт назвиається конструктором. У новому файлі створимо клас Webpage і в конструктор передамо параметр.
```php
<?php
class Webpage
{
    var $bgcolor;
    function Webpage($color)
    {
        $this->bgcolor = $color;
    }
}
$page = new Webpage("brown");
?>		
```
**Зауваження.** В залежності від кількості переданих параметрів можуть викликатися різні конструктори. У розглянутому прикладі об'єкти класу Webpage можуть створюватися двома способами.

По-перше, ви можете викликати конструктор, який просто створює об'єкт, але не ініціалізує його властивості
```php
$page = new Webpage;
```
По-друге, об'єкт можна створити за допомогою конструктора, визначеного в класі - в цьому випадку ви створюєте об'єкт класу Webpage і привласнюєте значення його властивості bgcolor:
```php
$page = new Webpage("brown");
```
7. **Увага!** Приклади вище демонстрували виклик конструктора старого типу, починаючи з версії PHP 7.0 вони являються застарілими. На заміну прийшла така форма використання констструкторів `__construct()`.

Розглянемо детальніше роботу уніфікованого конструктора. Створимо файл Human.php в який помістимо клас з одноіменною назвою
```php
<?php
	class Human
	{
		var $name;
	}
	?>
```
8. Додамо конструктор до цього класу
```php
<?php
class Human
{
    var $name;
    function  __construct($nameofperson)
    {
        $this->name= $nameofperson;
    }
}
?>
```
9. Створимо об'єкти цього класу за допомогою ключового слова new та передамо у якості аргументів імена людей
```php
$firstObject = new Human("Іван");
$secondObject = new Human("Ярослав");
```
10. Додамо нову змінну до нашого класу
```php 

<?php
class Human
{
	var $name;
	var $age;
}
?>
```
11. Визначаємо конструктор ще раз, але на цей раз з двома аргументами:
```php
<?php
class Human
{
	var $name;
	function  __construct($nameofperson, $ageofperson)
	{
		$this->name= $nameofperson;
		$this->age= $ageofperson;
	}
}
?>
$firstObject = new Human("Іван", 23);
$secondObject = new Human("Ярослав", 35);
```
12. **Зауваження.** Відповідно до основ ООП PHP конструктор можна викликати НЕ більше одного разу, але ми можемо змінювати значення змінних-членів. Тому в класі Human створіть два методи, один встановлює вік, а другий - ім'я. 
```php

<?php
class Human
{
	var $name;
	function  __construct($nameofperson, $ageofperson)
	{
		$this->name= $nameofperson;
		$this->age= $ageofperson;
	}
	function set_name($newname)
	{
		$this->name=$newname;
	}
	function set_age($newage)
	{
		$this->age=$newage;
	}
}
?>
```
13. Самостійно викличіть вже створені методи та додайте два нових методи для виведення ім'я та віку

14. Підтримка деструктора для класу, що визначається як метод `__destruct()`. Коли звільняється останнє посилання на об'єкт, перед вивільненням пам'яті, що займає цей об'єкт, викликається метод-деструктор, який не приймає параметрів.
```php
<?php
class Car
{
	function __construct()
	{
		print "Constructor";
		$this->name = "Car";
	}
	function __destruct()
	{
		print "Destroying " . $this->name;
	}
}
$obj = new Car();
?>
```
Цей деструктор виводить повідомлення про те, що об'єкт був знищений.

**Зауваження!** Деструктор так само, як і конструктор, викликається тільки один раз - в момент видалення об'єкта.

15. Давайте створимо клас Post для простих записів у блозі.
```php
<?php
class Post
{
	private $title;
	private $text;
	public function __construct(string $title, string $text)
	{
		$this->title = $title;
		$this->text = $text;
	}
	public function getTitle()
	{
		return $this->title;
	}
	public function setTitle($title): void
	{
		$this->title = $title;
	}
	public function getText()
	{
		return $this->text;
	}
	public function setText($text): void
	{
		$this->text = $text;
	}
}
?>
```
16. Клас може успадкувати від іншого класу властивості і методи. Робиться це за допомогою ключового слова extends. Таким чином:
```php
class Lesson extends Post
{
// Тіло класу Lesson
}
```
17. У якості батьківського класу за допомогою слова extends можна вказати тільки один клас. Однак, у класу Lesson, в свою чергу, теж можуть бути спадкоємці. Вони успадкують всі властивості і методи всіх своїх батьків.

При цьому доступними всередині об'єктів класу-спадкоємця будуть тільки властивості або методи, оголошені в батьківському класі як public або protected. Властивості і методи, з модифікатором доступу private НЕ будуть успадковані дочірніми класами.

Тобто, якщо ми хочемо в класі Lesson оголосити метод, який буде працювати з властивостями title і text, то ми повинні визначити ці властивості не як private, а як protected:
```php
class Post
{
	protected $title;
	protected $text;
...
```
18. Тепер ми можемо працювати з ними і в класі Lesson:
```php
class Lesson extends Post
{
private $homework;
public function __construct(string $title, string $text, string $homework)
{
    $this->title = $title;
    $this->text = $text;
    $this->homework = $homework;
}
public function getHomework(): string
{
    return $this->homework;
}
public function setHomework(string $homework): void
{
    $this->homework = $homework;
}
}
```
Ось таким чином ми розширили клас Lesson, успадкувавши його від класу Post та уникнувши копіювання коду

19. При цьому в об'єктах класу Lesson нам так само доступні всі protected і public методи, оголошені в батьківському класі. Давайте переконаємося в цьому у тому ж файлі виконаємо наступний код
```php
$lesson = new Lesson('Заголовок', 'Текст', 'Завдання');
echo 'Назва предмету: ' . $lesson->getTitle();
```
Ми отримаємо наступне
**Назва предмету: Заголовок**

20. Давайте тепер повернемося до модифікаторів доступу і до кінця з'ясуємо ситуацію, як кожен модифікатор впливає на методи і властивості: 
 + private - доступні тільки всередині об'єктів цього класу, недоступні в об'єктах класів-спадкоємців;
 + protected - доступні всередині об'єктів цього класу і всіх об'єктах класів-спадкоємців. При цьому недоступні ззовні;
 + public - доступні як всередині об'єктів класу, так і зовні - можемо безпосередньо звертатися до них ззовні. Доступні об'єктам класів-спадкоємців.

21. Якщо звернути увагу на класи Post і Lesson, то можна помітити деяке дублювання коду в конструкторі. Ми і там і там виконуємо однакові дії для властивостей title і text. Було б непогано від цього позбутися, скориставшись в Lesson вже готовим функціоналом з Post. 

Для цього ми можемо викликати батьківський конструктор в конструкторі дочірнього класу.
```php
class Lesson extends Post
{
private $homework;
public function __construct(string $title, string $text, string $homework)
{
    parent::__construct($title, $text);
    $this->homework = $homework;
}
...
```
22. Самостійно замініть конструктор класу Lesson кодом поданим вище та перевірте результат
```php
$lesson = new Lesson('Заголовок', 'Текст', 'Завдання');
var_dump($lesson);
```

Результат

```php
object(Lesson)[1]
private 'homework' => string 'Завдання' (length=14)
protected 'title' => string 'Заголовок' (length=18)
protected 'text' => string 'Текст' (length=10)
```

**Зауваження.** Звернення до елементів класу здійснюється за допомогою оператора :: "подвійна двокрапка". Використовуючи "подвійну двокрапку", можна звертатися до методів класів. У новому файлі опрацюйте нижче поданий приклад 

```php
<?php
class A
{
    function example()
    {
        echo "Першопочаткова функція A::example().<br>";
    }
}
class B extends A
{
    function example()
    {
        echo "Перевизначена функція B::example().<br>";
        A::example();
    }
}
A::example();
$b = new B;
$b->example();
?>
```

23. Виконати індивідуальне завдання
    
    + Створити клас Car, в якому буде міститися така інформація: марка, колір та максимальна швидкість. Висвести на екран всю інформацію про автомобіль.
    + Створіть ще один клас, який є спадкоємцем класу Lesson - PaidLesson (платний урок).
    + Оголосіть в ньому властивість price, а також геттери і сеттери для цієї властивості.
    + Додайте в конструкторі параметр, через який це властивість буде встановлюватися при створенні об'єкта.
    + Заповніть властивості об'єкту цього класу відповідними значеннями.
    + Виведіть цей об'єкт за допомогою `var_dump()`
    + Для кожного етапу роботи зробити знімки екрану та додати їх у звіт з описом кожного скіншота
    + Додати програмний код завдання для самомтійного виконання
    + Дати відповіді на контрольні запитання
    + Зберегти звіт у форматі PDF

## Контрольні питання
1. Що таке клас та екземпляр класу в ООП?
2. Коли відбувається ініціалізація властивостей класу?
3. Для чого використовується вказівник `$this`?
4. Як можна викликати батьківський конструктор в конструкторі дочірнього класу?
5. За допомогою якого методу доступа можна отримати доступ з поточного та дочірнього класу?
6. Якою функцією можна імітувати роботу деструктора?
7. Для чого призначений оператор new?

