# Функции, определяемые пользователем

Приведём пример синтаксиса, используемого для описания функций:

Пример #1 Псевдокод для демонстрации использования функций

```php
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Пример функции.\n";
    return $retval;
}
?>
```

Внутри функции можно использовать любой корректный PHP-код, в том числе другие функции и даже объявления классов.

Имена функций следуют тем же правилам, что и другие метки в PHP. Корректное имя функции начинается с буквы или знака подчёркивания, за которым следует любое количество букв, цифр или знаков подчёркивания. В качестве регулярного выражения оно может быть выражено так: `^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$`.

Подсказка
Смотрите также Руководство по именованию.

Функции не обязаны быть определены до их использования, исключая тот случай, когда функции определяются условно, как это показано в двух последующих примерах.

В случае, когда функция определяется в зависимости от какого-либо условия, например, как это показано в двух приведённых ниже примерах, обработка описания функции должна предшествовать её вызову.

Пример #2 Функции, зависящие от условий

```php
<?php

$makefoo = true;

/* Мы не можем вызвать функцию foo() в этом месте,
   поскольку она ещё не определена, но мы можем
   обратиться к bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Я не существую до тех пор, пока выполнение программы меня не достигнет.\n";
  }
}

/* Теперь мы благополучно можем вызывать foo(),
   поскольку $makefoo была интерпретирована как true */

if ($makefoo) foo();

function bar()
{
  echo "Я существую сразу с начала старта программы.\n";
}

?>
```

Пример #3 Вложенные функции

```php
<?php
function foo()
{
  function bar()
  {
    echo "Я не существую пока не будет вызвана foo().\n";
  }
}

/* Мы пока не можем обратиться к bar(),
   поскольку она ещё не определена. */

foo();

/* Теперь мы можем вызвать функцию bar(),
   обработка foo() сделала её доступной. */

bar();

?>
```

Все функции и классы PHP имеют глобальную область видимости - они могут быть вызваны вне функции, даже если были определены внутри и наоборот.

PHP не поддерживает перегрузку функции, также отсутствует возможность переопределить или удалить объявленную ранее функцию.

Замечание: Имена функций регистронезависимы для символов ASCII от A до Z, тем не менее, предпочтительнее вызывать функции так, как они были объявлены.

Функции PHP поддерживают как списки аргументов переменной длины, так и значения аргументов по умолчанию. Смотрите также описания функций func_num_args(), func_get_arg() и func_get_args() для более детальной информации.

Можно вызывать функции PHP рекурсивно.

Пример #4 Рекурсивные функции

```php
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
```



Аргументы функции ¶
Функция может принимать информацию в виде списка аргументов, который является списком разделённых запятыми выражений. Аргументы вычисляются слева направо перед фактическим вызовом функции (энергичное вычисление).

PHP поддерживает передачу аргументов по значению (по умолчанию), передачу аргументов по ссылке, и значения по умолчанию. Списки аргументов переменной длины и именованные аргументы также поддерживаются.

Пример #1 Передача массива в функцию

```php
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
```

Начиная с PHP 8.0.0, список аргументов функции может содержать завершающую запятую, которая будет проигнорирована. Это полезно в случае, когда список аргументов очень длинный, либо если имена переменных длинны, что подталкивает к их вертикальному расположению.

Пример #2 Список аргументов функции с завершающей запятой

```php
<?php
function takes_many_args(
    $first_arg,
    $second_arg,
    $a_very_long_argument_name,
    $arg_with_default = 5,
    $again = 'a default string', // Эта завершающая запятая допустима только начиная с  8.0.0.
)
{
    // ...
}
?>
```

Передача аргументов по ссылке ¶
По умолчанию аргументы в функцию передаются по значению (это означает, что если вы измените значение аргумента внутри функции, то вне её значение всё равно останется прежним). Если вы хотите разрешить функции модифицировать свои аргументы, вы должны передавать их по ссылке.

Если вы хотите, чтобы аргумент всегда передавался по ссылке, вы можете указать амперсанд (&) перед именем аргумента в описании функции:

Пример #3 Передача аргументов по ссылке

```php
<?php
function add_some_extra(&$string)
{
    $string .= 'и кое-что ещё.';
}
$str = 'Это строка, ';
add_some_extra($str);
echo $str;    // выведет 'Это строка, и кое-что ещё.'
?>
```

Передача значения в качестве аргумента, которое должно передаваться по ссылке, является ошибкой.

Значения аргументов по умолчанию ¶
Функция может определять значения по умолчанию для аргументов, используя синтаксис, подобный присвоению переменной. Значение по умолчанию используется только в том случае, если параметр не указан; в частности, обратите внимание, что передача null не присваивает значение по умолчанию.

Пример #4 Использование значений по умолчанию в определении функции

```php
<?php
function makecoffee($type = "капучино")
{
    return "Готовим чашку $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("эспрессо");
?>
```

Результат выполнения данного примера:

Готовим чашку капучино.
Готовим чашку .
Готовим чашку эспрессо.
Значениями параметров по умолчанию могут быть скалярные значения, массивы (array), специальный тип null, и, начиная с версии PHP 8.1.0, объекты, использующие синтаксис new ClassName().

Пример #5 Использование нескалярных типов в качестве значений по умолчанию

```php
<?php
function makecoffee($types = array("капучино"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "вручную" : $coffeeMaker;
    return "Готовлю чашку ".join(", ", $types)." $device.\n";
}
echo makecoffee();
echo makecoffee(array("капучино", "лавацца"), "в чайнике");
?>
```

Пример #6 Использование объектов в качестве значений по умолчанию (начиная с PHP 8.1.0)

```php
<?php
class DefaultCoffeeMaker {
    public function brew() {
        return 'Приготовление кофе.';
    }
}
class FancyCoffeeMaker {
    public function brew() {
        return 'Приготовление прекрасного кофе специально для вас.';
    }
}
function makecoffee($coffeeMaker = new DefaultCoffeeMaker)
{
    return $coffeeMaker->brew();
}
echo makecoffee();
echo makecoffee(new FancyCoffeeMaker);
?>
```

Значение по умолчанию должно быть константным выражением, а не (к примеру) переменной или вызовом функции/метода класса.

Обратите внимание, что любые необязательные аргументы должны быть указаны после любых обязательных аргументов, иначе они не могут быть опущены при вызове. Рассмотрим следующий пример:

Пример #7 Некорректное использование значений по умолчанию

```php
<?php
function makeyogurt($container = "миску", $flavour)
{
    return "Делаем $container с $flavour йогуртом.\n";
}

echo makeyogurt("малиновым"); // "малиновым" - это $container, не $flavour
?>
```

Результат выполнения данного примера:

Fatal error: Uncaught ArgumentCountError: Too few arguments
to function makeyogurt(), 1 passed in example.php on line 42
Теперь сравним его со следующим примером:

Пример #8 Корректное использование значений по умолчанию

```php
<?php
function makeyogurt($flavour, $container = "миску")
{
    return "Делаем $container с $flavour йогуртом.\n";
}

echo makeyogurt("малиновым"); // "малиновым" - это $flavour
?>
```

Результат выполнения данного примера:

Делаем миску с малиновым йогуртом.
Начиная с PHP 8.0.0, именованные аргументы можно использовать для пропуска нескольких необязательных параметров.

Пример #9 Правильное использование аргументов функций по умолчанию

```php
<?php
function makeyogurt($container = "миску", $flavour = "малиновым", $style = "греческим")
{
    return "Делаем $container с $flavour $style йогуртом.\n";
}
echo makeyogurt(style: "натуральным");
?>
```

Результат выполнения данного примера:

Делаем миску с малиновым натуральным йогуртом.
Начиная с PHP 8.0.0, объявление обязательных аргументов после необязательных аргументов является устаревшим. Обычно это можно решить отказавшись от значения по умолчанию, поскольку оно никогда не будет использоваться. Исключением из этого правила являются аргументы вида Type $param = null, где null по умолчанию делает тип неявно обнуляемым. Такое использование остаётся допустимым, хотя рекомендуется использовать явный тип nullable.

Пример #10 Объявление необязательных аргументов после обязательных аргументов

```php
<?php
function foo($a = [], $b) {} // По умолчанию не используется; устарел, начиная с версии PHP 8.0.0
function foo($a, $b) {}      // Функционально эквивалентны, без уведомления об устаревании
function bar(A $a = null, $b) {} // Все еще разрешено; $a является обязательным, но допускающим значение null
function bar(?A $a, $b) {}       // Рекомендуется
?>
```

Замечание: Начиная с PHP 7.1.0, опущение параметра, не заданного по умолчанию, выбрасывает исключение ArgumentCountError; в предыдущих версиях это вызывало предупреждение.

Замечание: Значения по умолчанию могут быть переданы по ссылке.

Списки аргументов переменной длины ¶
PHP поддерживает списки аргументов переменной длины для функций, определяемых пользователем с помощью добавления многоточия (...).

Замечание: Также можно добиться аргументов переменной длины, используя функции func_num_args(), func_get_arg() и func_get_args(). Этот метод не рекомендуется, поскольку он использовался до введения многоточия (...).

Список аргументов может содержать многоточие (...), чтобы показать, что функция принимает переменное количество аргументов. Аргументы в этом случае будут переданы в виде массива. Например:

Пример #11 Использование ... для доступа к аргументам

```php
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
```

Результат выполнения данного примера:

10
Многоточие (...) можно использовать при вызове функции, чтобы распаковать массив (array) или Traversable переменную в список аргументов:

Пример #12 Использование ... для передачи аргументов

```php
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
```

Результат выполнения данного примера:

3
3
Можно задать несколько аргументов в привычном виде, а затем добавить .... В этом случае ... поместит в массив только те аргументы, которые не нашли соответствия указанным в объявлении функции.

Также можно добавить объявление типа перед .... В этом случае, все аргументы, обработанные многоточием (...), должны соответствовать этому типу параметра.

Пример #13 Аргументы с подсказкой типа

```php
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// Это не сработает, т.к. null не является объектом DateInterval.
echo total_intervals('d', null);
?>
```

Результат выполнения данного примера:

3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
В конце концов, можно передавать аргументы по ссылке. Для этого перед ... нужно поставить амперсанд (&).

Предыдущие версии PHP ¶
Для указания того, что функция принимает переменное число аргументов, никакой специальный синтаксис не используется. Для доступа к аргументам необходимо использовать функции func_num_args(), func_get_arg() и func_get_args().

В первом примере выше было показано, как задать список аргументов переменной длины для предыдущих версий PHP:

Пример #14 Доступ к аргументам в предыдущих версиях PHP

```php
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
```

Результат выполнения данного примера:

10
Именованные аргументы ¶
В PHP 8.0.0 в виде продолжения позиционных параметров появились именованные аргументы. С их помощью аргументы функции можно передавать по имени параметра, а не по его позиции. Таким образом аргумент становится самодокументированным, независимым от порядка и указанного значения по умолчанию.

Именованные аргументы передаются путём добавления через двоеточия имени параметра перед его значением. В качестве имён параметров можно использовать зарезервированные ключевые слова. Имя параметра должно быть идентификатором, т.е. он не может быть создан динамически.

Пример #15 Синтаксис именованного аргумента

```php
<?php
myFunction(paramName: $value);
array_foobar(array: $value);

// НЕ поддерживается.
function_name($variableStoringParamName: $value);
?>
```

Пример #16 Позиционные аргументы в сравнении с именованными аргументами

```php
<?php
// Использование позиционных аргументов:
array_fill(0, 100, 50);

// Использование именованных аргументов:
array_fill(start_index: 0, count: 100, value: 50);
?>
```

Порядок, в котором передаются именованные аргументы, не имеет значения.

Пример #17 Тот же пример, что и выше, но с другим порядком параметров

```php
<?php
array_fill(value: 50, count: 100, start_index: 0);
?>
```

Именованные аргументы можно комбинировать с позиционными. В этом случае именованные аргументы должны следовать после позиционных аргументов. Также возможно передать только часть необязательных аргументов функции, независимо от их порядка.

Пример #18 Объединение именованных аргументов с позиционными аргументами

```php
<?php
htmlspecialchars($string, double_encode: false);
// То же самое
htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML401, 'UTF-8', false);
?>
```

Передача одного и того же параметра несколько раз приводит к выбрасыванию исключения Error.

Пример #19 Ошибка, возникающая при передаче одного и того же параметра несколько раз

```php
<?php
function foo($param) { ... }

foo(param: 1, param: 2);
// Error: Named parameter $param overwrites previous argument
foo(1, param: 2);
// Error: Named parameter $param overwrites previous argument
?>
```

Начиная с PHP 8.1.0, можно использовать именованные аргументы после распаковки аргументов. Именованный аргумент не должен переопределять уже распакованные аргументы.

Пример #20 Пример использования именованных аргументов после распаковки

```php
<?php
function foo($a, $b, $c = 3, $d = 4) {
  return $a + $b + $c + $d;
}
var_dump(foo(...[1, 2], d: 40)); // 46
var_dump(foo(...['b' => 2, 'a' => 1], d: 40)); // 46
var_dump(foo(...[1, 2], b: 20)); // Фатальная ошибка. Именованный аргумент $b переопределяет предыдущий аргумент
?>
```



Возврат значений ¶
Значения возвращаются при помощи необязательного оператора возврата. Возвращаемые значения могут быть любого типа, в том числе это могут быть массивы и объекты. Возврат приводит к завершению выполнения функции и передаче управления обратно к той строке кода, в которой данная функция была вызвана. Для получения более детальной информации ознакомьтесь с описанием return.

Замечание:

Если конструкция return не указана, то функция вернёт значение null.

Использование выражения return
Пример #1 Использование конструкции return

```php
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // выводит '16'.
?>
```

Функция не может возвращать несколько значений, но аналогичного результата можно добиться, возвращая массив.

Пример #2 Возврат нескольких значений в виде массива

```php
<?php
function small_numbers()
{
    return [0, 1, 2];
}
// Деструктуризация массива будет собирать каждый элемент массива индивидуально
[$zero, $one, $two] = small_numbers();

// До версии 7.1.0 единственной эквивалентной альтернативой было использование конструкции list().
list($zero, $one, $two) = small_numbers();

?>
```

Для того, чтобы функция возвращала результат по ссылке, вам необходимо использовать оператор & и при описании функции, и при присвоении переменной возвращаемого значения:

Пример #3 Возврат результата по ссылке

```php
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
```

Для получения более детальной информации о ссылках обратитесь к разделу документации Подробно о ссылках.